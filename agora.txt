-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package agora
@version 0.1


-- | A basic N of M multisignature validation function.
module Agora.MultiSig

-- | Check if a Haskell-level MultiSig signs this transaction.
validatedByMultisig :: MultiSig -> Term s (PTxInfo :--> PBool)

-- | Check if a Plutarch-level MultiSig signs this transaction.
pvalidatedByMultisig :: Term s (PMultiSig :--> (PTxInfo :--> PBool))

-- | Plutarch-level MultiSig
newtype PMultiSig (s :: S)
PMultiSig :: Term s (PDataRecord '["keys" := PBuiltinList (PAsData PPubKeyHash), "minSigs" := PInteger]) -> PMultiSig (s :: S)
[getMultiSig] :: PMultiSig (s :: S) -> Term s (PDataRecord '["keys" := PBuiltinList (PAsData PPubKeyHash), "minSigs" := PInteger])

-- | A MultiSig represents a proof that a particular set of signatures are
--   present on a transaction.
data MultiSig
MultiSig :: [PubKeyHash] -> Integer -> MultiSig

-- | List of PubKeyHashes that must be present in the list of signatories.
[keys] :: MultiSig -> [PubKeyHash]
[minSigs] :: MultiSig -> Integer
instance Plutarch.DataRepr.Internal.Field.PDataFields Agora.MultiSig.PMultiSig
instance Plutarch.Builtin.PIsData Agora.MultiSig.PMultiSig
instance Plutarch.Internal.PlutusType.PlutusType Agora.MultiSig.PMultiSig
instance Plutarch.DataRepr.Internal.PIsDataRepr Agora.MultiSig.PMultiSig
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.MultiSig.PMultiSig s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.MultiSig.PMultiSig s)
instance Plutarch.Lift.PConstant Agora.MultiSig.MultiSig
instance Plutarch.Lift.PUnsafeLiftDecl Agora.MultiSig.PMultiSig
instance PlutusTx.IsData.Class.ToData Agora.MultiSig.MultiSig
instance PlutusTx.IsData.Class.FromData Agora.MultiSig.MultiSig
instance PlutusTx.IsData.Class.UnsafeFromData Agora.MultiSig.MultiSig
instance PlutusTx.Lift.Class.Typeable @Type PlutusCore.Default.Universe.DefaultUni Agora.MultiSig.MultiSig
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Agora.MultiSig.MultiSig
instance Generics.SOP.Universe.Generic Agora.MultiSig.MultiSig
instance GHC.Show.Show Agora.MultiSig.MultiSig
instance GHC.Classes.Eq Agora.MultiSig.MultiSig
instance GHC.Generics.Generic Agora.MultiSig.MultiSig


-- | Tags and extras for <a>Plutarch.SafeMoney</a>.
module Agora.SafeMoney

-- | ADA.
data ADATag

-- | Governance token.
data GTTag

-- | Resolves ada tags.
adaRef :: Tagged ADATag AssetClass


-- | Proposal scripts encoding effects that operate on the system.
module Agora.Proposal

-- | Parameters that identify the Proposal validator script.
data Proposal
Proposal :: Proposal

-- | Haskell-level datum for Proposal scripts.
data ProposalDatum
ProposalDatum :: Map ResultTag [(ValidatorHash, DatumHash)] -> ProposalStatus -> [PubKeyHash] -> ProposalThresholds -> ProposalVotes -> ProposalDatum

-- | Effect lookup table. First by result, then by effect hash.
[effects] :: ProposalDatum -> Map ResultTag [(ValidatorHash, DatumHash)]

-- | The status the proposal is in.
[status] :: ProposalDatum -> ProposalStatus

-- | Who created the proposal initially, and who cosigned it later.
[cosigners] :: ProposalDatum -> [PubKeyHash]

-- | Thresholds copied over on initialization.
[thresholds] :: ProposalDatum -> ProposalThresholds

-- | Vote tally on the proposal
[votes] :: ProposalDatum -> ProposalVotes

-- | The "status" of the proposal. This is only useful for state
--   transitions, as opposed to time-based "phases".
--   
--   If the proposal is <a>VotingReady</a>, for instance, that doesn't
--   necessarily mean that voting is possible, as this also requires the
--   timing to be right.
data ProposalStatus

-- | A draft proposal represents a proposal that has yet to be realized.
--   
--   In effect, this means one which didn't have enough LQ to be a full
--   proposal, and needs cosigners to enable that to happen. This is
--   similar to a "temperature check", but only useful if multiple people
--   want to pool governance tokens together. If the proposal doesn't get
--   to <a>VotingReady</a> on time, the proposal will <b>never</b> be able
--   to get voted on.
Draft :: ProposalStatus

-- | The proposal has/had enough GT cosigned in order to be a fully fledged
--   proposal.
--   
--   This means that once the timing requirements align, proposal will be
--   able to be voted on.
VotingReady :: ProposalStatus

-- | The proposal has finished.
--   
--   This can mean it's been voted on and completed, but it can also mean
--   the proposal failed due to time constraints or didn't get to
--   <a>VotingReady</a> first.
--   
--   TODO: The owner of the proposal may choose to reclaim their proposal.
Finished :: ProposalStatus

-- | The threshold values for various state transitions to happen. This
--   data is stored centrally (in the <a>Governor</a>) and copied over to
--   <a>Proposal</a>s when they are created.
data ProposalThresholds
ProposalThresholds :: Tagged GTTag Integer -> Tagged GTTag Integer -> Tagged GTTag Integer -> ProposalThresholds

-- | How much GT minimum must a particular <a>ResultTag</a> accumulate for
--   it to pass.
[execute] :: ProposalThresholds -> Tagged GTTag Integer

-- | How much GT required to "create" a proposal.
[draft] :: ProposalThresholds -> Tagged GTTag Integer

-- | How much GT required to allow voting to happen. (i.e. to move into
--   <a>VotingReady</a>)
[vote] :: ProposalThresholds -> Tagged GTTag Integer

-- | Map which encodes the total tally for each result. It's important that
--   the "shape" is consistent with the shape of <a>effects</a>.
--   
--   e.g. if the <a>effects</a> field looks like the following:
--   
--   <pre>
--   [(<a>ResultTag</a> 0, []), (<a>ResultTag</a> 1, [(vh, dh)])]
--   </pre>
--   
--   Then <a>ProposalVotes</a> needs be of the shape:
--   
--   <pre>
--   [(<a>ResultTag</a> 0, n), (<a>ResultTag</a> 1, m)]
--   </pre>
newtype ProposalVotes
ProposalVotes :: Map ResultTag Integer -> ProposalVotes
[getProposalVotes] :: ProposalVotes -> Map ResultTag Integer

-- | Identifies a Proposal, issued upon creation of a proposal. In
--   practice, this number starts at zero, and increments by one for each
--   proposal. The 100th proposal will be <tt><a>ProposalId</a> 99</tt>.
--   This counter lives in the <tt>Governor</tt>, see
--   <tt>nextProposalId</tt>.
newtype ProposalId
ProposalId :: Integer -> ProposalId
[proposalTag] :: ProposalId -> Integer

-- | Encodes a result. Typically, for a Yes/No proposal, we encode it like
--   this:
--   
--   <pre>
--   <a>No</a>  ~ <a>ResultTag</a> 0
--   <a>Yes</a> ~ <a>ResultTag</a> 1
--   </pre>
newtype ResultTag
ResultTag :: Integer -> ResultTag
[getResultTag] :: ResultTag -> Integer

-- | Plutarch-level version of <a>ProposalDatum</a>.
newtype PProposalDatum (s :: S)
PProposalDatum :: Term s (PDataRecord '["effects" := PMap PResultTag (PMap PValidatorHash PDatumHash), "status" := PProposalStatus, "cosigners" := PBuiltinList PPubKeyHash, "thresholds" := PProposalThresholds, "votes" := PProposalVotes]) -> PProposalDatum (s :: S)
[getProposalDatum] :: PProposalDatum (s :: S) -> Term s (PDataRecord '["effects" := PMap PResultTag (PMap PValidatorHash PDatumHash), "status" := PProposalStatus, "cosigners" := PBuiltinList PPubKeyHash, "thresholds" := PProposalThresholds, "votes" := PProposalVotes])

-- | Plutarch-level version of <a>ProposalStatus</a>.
data PProposalStatus (s :: S)
PDraft :: Term s (PDataRecord '[]) -> PProposalStatus (s :: S)
PVotingReady :: Term s (PDataRecord '[]) -> PProposalStatus (s :: S)
PFinished :: Term s (PDataRecord '[]) -> PProposalStatus (s :: S)

-- | Plutarch-level version of <a>ProposalThresholds</a>.
newtype PProposalThresholds (s :: S)
PProposalThresholds :: Term s (PDataRecord '["execute" := PDiscrete GTTag, "draft" := PDiscrete GTTag, "vote" := PDiscrete GTTag]) -> PProposalThresholds (s :: S)
[getProposalThresholds] :: PProposalThresholds (s :: S) -> Term s (PDataRecord '["execute" := PDiscrete GTTag, "draft" := PDiscrete GTTag, "vote" := PDiscrete GTTag])

-- | Plutarch-level version of <a>ProposalVotes</a>.
newtype PProposalVotes (s :: S)
PProposalVotes :: Term s (PMap PResultTag PInteger) -> PProposalVotes (s :: S)

-- | Plutarch-level version of <a>PProposalId</a>.
newtype PProposalId (s :: S)
PProposalId :: Term s PInteger -> PProposalId (s :: S)

-- | Plutarch-level version of <a>ResultTag</a>.
newtype PResultTag (s :: S)
PResultTag :: Term s PInteger -> PResultTag (s :: S)

-- | Validator for Proposals.
proposalValidator :: Proposal -> ClosedTerm PValidator

-- | Policy for Proposals.
proposalPolicy :: Proposal -> ClosedTerm PMintingPolicy
instance GHC.Generics.Generic Agora.Proposal.ProposalId
instance GHC.Show.Show Agora.Proposal.ProposalId
instance GHC.Classes.Eq Agora.Proposal.ProposalId
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Proposal.ProposalId
instance PlutusTx.IsData.Class.FromData Agora.Proposal.ProposalId
instance PlutusTx.IsData.Class.ToData Agora.Proposal.ProposalId
instance Plutarch.Bool.POrd Agora.Proposal.PResultTag
instance Plutarch.Bool.PEq Agora.Proposal.PResultTag
instance Plutarch.Builtin.PIsData Agora.Proposal.PResultTag
instance Plutarch.Internal.PlutusType.PlutusType Agora.Proposal.PResultTag
instance Plutarch.Bool.POrd Agora.Proposal.PProposalId
instance Plutarch.Bool.PEq Agora.Proposal.PProposalId
instance Plutarch.Builtin.PIsData Agora.Proposal.PProposalId
instance Plutarch.Internal.PlutusType.PlutusType Agora.Proposal.PProposalId
instance Plutarch.Builtin.PIsData Agora.Proposal.PProposalStatus
instance Plutarch.Internal.PlutusType.PlutusType Agora.Proposal.PProposalStatus
instance Plutarch.DataRepr.Internal.PIsDataRepr Agora.Proposal.PProposalStatus
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.Proposal.PProposalStatus s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.Proposal.PProposalStatus s)
instance Plutarch.DataRepr.Internal.Field.PDataFields Agora.Proposal.PProposalThresholds
instance Plutarch.Builtin.PIsData Agora.Proposal.PProposalThresholds
instance Plutarch.Internal.PlutusType.PlutusType Agora.Proposal.PProposalThresholds
instance Plutarch.DataRepr.Internal.PIsDataRepr Agora.Proposal.PProposalThresholds
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.Proposal.PProposalThresholds s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.Proposal.PProposalThresholds s)
instance Plutarch.Builtin.PIsData Agora.Proposal.PProposalVotes
instance Plutarch.Internal.PlutusType.PlutusType Agora.Proposal.PProposalVotes
instance Plutarch.DataRepr.Internal.Field.PDataFields Agora.Proposal.PProposalDatum
instance Plutarch.Builtin.PIsData Agora.Proposal.PProposalDatum
instance Plutarch.Internal.PlutusType.PlutusType Agora.Proposal.PProposalDatum
instance Plutarch.DataRepr.Internal.PIsDataRepr Agora.Proposal.PProposalDatum
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.Proposal.PProposalDatum s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.Proposal.PProposalDatum s)
instance Plutarch.Lift.PConstant Agora.Proposal.ResultTag
instance Plutarch.Lift.PConstant Agora.Proposal.ProposalId
instance Plutarch.Lift.PConstant Agora.Proposal.ProposalStatus
instance Plutarch.Lift.PConstant Agora.Proposal.ProposalThresholds
instance Plutarch.Lift.PConstant Agora.Proposal.ProposalVotes
instance Plutarch.Lift.PConstant Agora.Proposal.ProposalDatum
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Proposal.PProposalDatum
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Proposal.PProposalVotes
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Proposal.PProposalThresholds
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Proposal.PProposalStatus
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Proposal.PProposalId
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Proposal.PResultTag
instance PlutusTx.IsData.Class.ToData Agora.Proposal.ProposalDatum
instance PlutusTx.IsData.Class.FromData Agora.Proposal.ProposalDatum
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Proposal.ProposalDatum
instance GHC.Generics.Generic Agora.Proposal.ProposalVotes
instance GHC.Show.Show Agora.Proposal.ProposalVotes
instance GHC.Classes.Eq Agora.Proposal.ProposalVotes
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Proposal.ProposalVotes
instance PlutusTx.IsData.Class.FromData Agora.Proposal.ProposalVotes
instance PlutusTx.IsData.Class.ToData Agora.Proposal.ProposalVotes
instance GHC.Generics.Generic Agora.Proposal.ProposalDatum
instance GHC.Show.Show Agora.Proposal.ProposalDatum
instance GHC.Classes.Eq Agora.Proposal.ProposalDatum
instance PlutusTx.IsData.Class.ToData Agora.Proposal.ProposalThresholds
instance PlutusTx.IsData.Class.FromData Agora.Proposal.ProposalThresholds
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Proposal.ProposalThresholds
instance GHC.Generics.Generic Agora.Proposal.ProposalThresholds
instance GHC.Show.Show Agora.Proposal.ProposalThresholds
instance GHC.Classes.Eq Agora.Proposal.ProposalThresholds
instance PlutusTx.IsData.Class.ToData Agora.Proposal.ProposalStatus
instance PlutusTx.IsData.Class.FromData Agora.Proposal.ProposalStatus
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Proposal.ProposalStatus
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Proposal.ResultTag
instance PlutusTx.IsData.Class.FromData Agora.Proposal.ResultTag
instance PlutusTx.IsData.Class.ToData Agora.Proposal.ResultTag
instance GHC.Classes.Ord Agora.Proposal.ResultTag
instance GHC.Show.Show Agora.Proposal.ResultTag
instance GHC.Classes.Eq Agora.Proposal.ResultTag
instance GHC.Generics.Generic Agora.Proposal.ProposalStatus
instance GHC.Show.Show Agora.Proposal.ProposalStatus
instance GHC.Classes.Eq Agora.Proposal.ProposalStatus


-- | Governor entity scripts acting as authority of entire system.
module Agora.Governor

-- | Datum for the Governor script.
data GovernorDatum
GovernorDatum :: ProposalThresholds -> ProposalId -> GovernorDatum

-- | Gets copied over upon creation of a <a>ProposalDatum</a>.
[proposalThresholds] :: GovernorDatum -> ProposalThresholds

-- | What tag the next proposal will get upon creating.
[nextProposalId] :: GovernorDatum -> ProposalId

-- | Redeemer for Governor script. The governor has two primary
--   responsibilities:
--   
--   <ol>
--   <li>The gating of Proposal creation.</li>
--   <li>The gating of minting authority tokens.</li>
--   </ol>
data GovernorRedeemer

-- | Checks that a proposal was created lawfully, and allows it.
CreateProposal :: GovernorRedeemer

-- | Checks that a SINGLE proposal finished correctly, and allows minting
--   GATs for each effect script.
MintGATs :: GovernorRedeemer

-- | Parameters for creating Governor scripts.
data Governor
Governor :: Governor

-- | Policy for Governors.
governorPolicy :: Governor -> ClosedTerm PMintingPolicy

-- | Validator for Governors.
governorValidator :: Governor -> ClosedTerm PValidator


-- | Vote-lockable stake UTXOs holding GT.
module Agora.Stake

-- | Plutarch-level datum for Stake scripts.
newtype PStakeDatum (s :: S)
PStakeDatum :: Term s (PDataRecord '["stakedAmount" := PDiscrete GTTag, "owner" := PPubKeyHash, "lockedBy" := PBuiltinList (PAsData PProposalLock)]) -> PStakeDatum (s :: S)
[getStakeDatum] :: PStakeDatum (s :: S) -> Term s (PDataRecord '["stakedAmount" := PDiscrete GTTag, "owner" := PPubKeyHash, "lockedBy" := PBuiltinList (PAsData PProposalLock)])

-- | Plutarch-level redeemer for Stake scripts.
data PStakeRedeemer (s :: S)

-- | Deposit or withdraw a discrete amount of the staked governance token.
PDepositWithdraw :: Term s (PDataRecord '["delta" := PDiscrete GTTag]) -> PStakeRedeemer (s :: S)

-- | Destroy a stake, retrieving its LQ, the minimum ADA and any other
--   assets.
PDestroy :: Term s (PDataRecord '[]) -> PStakeRedeemer (s :: S)
PPermitVote :: Term s (PDataRecord '["lock" := PProposalLock]) -> PStakeRedeemer (s :: S)
PRetractVotes :: Term s (PDataRecord '["locks" := PBuiltinList PProposalLock]) -> PStakeRedeemer (s :: S)

-- | Haskell-level datum for Stake scripts.
data StakeDatum
StakeDatum :: Tagged GTTag Integer -> PubKeyHash -> [ProposalLock] -> StakeDatum

-- | Tracks the amount of governance token staked in the datum. This also
--   acts as the voting weight for <tt>Proposal</tt>s.
[stakedAmount] :: StakeDatum -> Tagged GTTag Integer

-- | The hash of the public key this stake belongs to.
--   
--   TODO Support for MultiSig/Scripts is tracked here:
--   <a>https://github.com/Liqwid-Labs/agora/issues/45</a>
[owner] :: StakeDatum -> PubKeyHash

-- | The current proposals locking this stake. This field must be empty for
--   the stake to be usable for deposits and withdrawals.
[lockedBy] :: StakeDatum -> [ProposalLock]

-- | Haskell-level redeemer for Stake scripts.
data StakeRedeemer

-- | Deposit or withdraw a discrete amount of the staked governance token.
--   Stake must be unlocked.
DepositWithdraw :: Tagged GTTag Integer -> StakeRedeemer

-- | Destroy a stake, retrieving its LQ, the minimum ADA and any other
--   assets. Stake must be unlocked.
Destroy :: StakeRedeemer

-- | Permit a Vote to be added onto a <tt>Proposal</tt>. This also adds a
--   lock to the <a>lockedBy</a> field. See <a>ProposalLock</a>. This needs
--   to be done in sync with casting a vote, otherwise it's possible for a
--   lock to be permanently placed on the stake, and then the funds are
--   lost.
PermitVote :: ProposalLock -> StakeRedeemer

-- | Retract a vote, removing it from the <a>lockedBy</a> field. See
--   <a>ProposalLock</a>. This action checks for permission of the
--   <tt>Proposal</tt>. Finished proposals are always allowed to have votes
--   retracted and won't affect the Proposal datum, allowing <a>Stake</a>s
--   to be unlocked.
RetractVotes :: [ProposalLock] -> StakeRedeemer

-- | A lock placed on a Stake datum in order to prevent depositing and
--   withdrawing when votes are in place.
--   
--   NOTE: Due to retracting votes always being possible, this lock will
--   only lock with contention on the proposal.
--   
--   FIXME: Contention on Proposals could create contention on voting which
--   in turn creates contention on stakers.
--   
--   Vaguely this is the dependency graph for this locking interaction.
--   Both the stake validator and the proposal validator are only able to
--   check for one another through the datum belonging to the ST:
--   
--   <pre>
--   ┌─────────────────┐   ┌────────────────────┐
--   │ Stake Validator ├─┐ │ Proposal Validator │
--   └────────┬────────┘ │ └──────┬─────┬───────┘
--            │          │        │     │
--            │        ┌─┼────────┘     │
--            ▼        │ │              ▼
--   ┌──────────────┐  │ │ ┌─────────────────┐
--   │ Stake Policy │◄─┘ └►│ Proposal Policy │
--   └──────────────┘      └─────────────────┘
--   
--   </pre>
data ProposalLock
ProposalLock :: ResultTag -> ProposalId -> ProposalLock

-- | What was voted on. This allows retracting votes to undo their vote.
[vote] :: ProposalLock -> ResultTag

-- | Identifies the proposal. See <a>ProposalId</a> for further comments on
--   its significance.
[proposalId] :: ProposalLock -> ProposalId
newtype PProposalLock (s :: S)
PProposalLock :: Term s (PDataRecord '["vote" := PResultTag, "proposalTag" := PProposalId]) -> PProposalLock (s :: S)
[getProposalLock] :: PProposalLock (s :: S) -> Term s (PDataRecord '["vote" := PResultTag, "proposalTag" := PProposalId])

-- | Parameters for creating Stake scripts.
newtype Stake
Stake :: Tagged GTTag AssetClass -> Stake

-- | Used when inlining the AssetClass of a <a>PDiscrete</a> in the script
--   code.
[gtClassRef] :: Stake -> Tagged GTTag AssetClass

-- | Policy for Stake state threads.
stakePolicy :: Stake -> ClosedTerm PMintingPolicy

-- | Validator intended for Stake UTXOs to live in.
stakeValidator :: Stake -> ClosedTerm PValidator

-- | Check whether a Stake is locked. If it is locked, various actions are
--   unavailable.
stakeLocked :: forall (s :: S). Term s (PStakeDatum :--> PBool)
instance Plutarch.DataRepr.Internal.Field.PDataFields Agora.Stake.PProposalLock
instance Plutarch.Builtin.PIsData Agora.Stake.PProposalLock
instance Plutarch.Internal.PlutusType.PlutusType Agora.Stake.PProposalLock
instance Plutarch.DataRepr.Internal.PIsDataRepr Agora.Stake.PProposalLock
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.Stake.PProposalLock s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.Stake.PProposalLock s)
instance Plutarch.Builtin.PIsData Agora.Stake.PStakeRedeemer
instance Plutarch.Internal.PlutusType.PlutusType Agora.Stake.PStakeRedeemer
instance Plutarch.DataRepr.Internal.PIsDataRepr Agora.Stake.PStakeRedeemer
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.Stake.PStakeRedeemer s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.Stake.PStakeRedeemer s)
instance Plutarch.DataRepr.Internal.Field.PDataFields Agora.Stake.PStakeDatum
instance Plutarch.Builtin.PIsData Agora.Stake.PStakeDatum
instance Plutarch.Internal.PlutusType.PlutusType Agora.Stake.PStakeDatum
instance Plutarch.DataRepr.Internal.PIsDataRepr Agora.Stake.PStakeDatum
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.Stake.PStakeDatum s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.Stake.PStakeDatum s)
instance Plutarch.Lift.PConstant Agora.Stake.StakeDatum
instance Plutarch.Lift.PConstant Agora.Stake.StakeRedeemer
instance Plutarch.Lift.PConstant Agora.Stake.ProposalLock
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Stake.PStakeDatum
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Stake.PStakeRedeemer
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Stake.PProposalLock
instance PlutusTx.IsData.Class.ToData Agora.Stake.StakeDatum
instance PlutusTx.IsData.Class.FromData Agora.Stake.StakeDatum
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Stake.StakeDatum
instance GHC.Generics.Generic Agora.Stake.StakeDatum
instance GHC.Show.Show Agora.Stake.StakeDatum
instance PlutusTx.IsData.Class.ToData Agora.Stake.StakeRedeemer
instance PlutusTx.IsData.Class.FromData Agora.Stake.StakeRedeemer
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Stake.StakeRedeemer
instance GHC.Generics.Generic Agora.Stake.StakeRedeemer
instance GHC.Show.Show Agora.Stake.StakeRedeemer
instance PlutusTx.IsData.Class.ToData Agora.Stake.ProposalLock
instance PlutusTx.IsData.Class.FromData Agora.Stake.ProposalLock
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Stake.ProposalLock
instance GHC.Generics.Generic Agora.Stake.ProposalLock
instance GHC.Show.Show Agora.Stake.ProposalLock


-- | Tokens acting as redeemable proofs of DAO authority.
module Agora.AuthorityToken

-- | Policy given <a>AuthorityToken</a> params.
authorityTokenPolicy :: AuthorityToken -> Term s (PData :--> (PScriptContext :--> PUnit))

-- | Check that all GATs are valid in a particular TxOut. How this is
--   checked: an AuthorityToken should never leave the Effect it was
--   initially sent to, so we simply check that the script address the
--   token resides in matches the TokenName. Since the TokenName was tagged
--   upon mint with the Effect script it was sent to, this is enough to
--   prove validity.
--   
--   In other words, check that all assets of a particular currency symbol
--   are tagged with a TokenName that matches where they live.
authorityTokensValidIn :: Term s (PCurrencySymbol :--> (PTxOut :--> PBool))

-- | Assert that a single authority token has been burned.
singleAuthorityTokenBurned :: forall (s :: S). Term s PCurrencySymbol -> Term s (PAsData PTxInfo) -> Term s PValue -> Term s PBool

-- | An AuthorityToken represents a proof that a particular token moved
--   while this token was minted. In effect, this means that the validator
--   that locked such a token must have approved said transaction. Said
--   validator should be made aware of *this* token's existence in order to
--   prevent incorrect minting.
newtype AuthorityToken
AuthorityToken :: AssetClass -> AuthorityToken

-- | Token that must move in order for minting this to be valid.
[authority] :: AuthorityToken -> AssetClass


-- | Contains the datum, redeemer and validator for a template DAO
--   treasury.
module Agora.Treasury

-- | Plutarch level type representing valid redeemers of the treasury.
newtype PTreasuryRedeemer (s :: S)

-- | Alters treasury parameters, subject to the burning of a governance
--   authority token.
PAlterTreasuryParams :: Term s (PDataRecord '[]) -> PTreasuryRedeemer (s :: S)

-- | Plutarch level type representing datum of the treasury. Contains:
--   
--   <ul>
--   <li><tt>stateThread</tt> representing the asset class of the
--   treasury's state thread token.</li>
--   </ul>
newtype PTreasuryDatum (s :: S)
PTreasuryDatum :: Term s (PDataRecord '["stateThread" := PCurrencySymbol]) -> PTreasuryDatum (s :: S)

-- | Validator ensuring that transactions consuming the treasury do so in a
--   valid manner.
treasuryValidator :: CurrencySymbol -> ClosedTerm PValidator
instance Plutarch.DataRepr.Internal.Field.PDataFields Agora.Treasury.PTreasuryDatum
instance Plutarch.Builtin.PIsData Agora.Treasury.PTreasuryDatum
instance Plutarch.Internal.PlutusType.PlutusType Agora.Treasury.PTreasuryDatum
instance Plutarch.DataRepr.Internal.PIsDataRepr Agora.Treasury.PTreasuryDatum
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.Treasury.PTreasuryDatum s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.Treasury.PTreasuryDatum s)
instance Plutarch.Builtin.PIsData Agora.Treasury.PTreasuryRedeemer
instance Plutarch.Internal.PlutusType.PlutusType Agora.Treasury.PTreasuryRedeemer
instance Plutarch.DataRepr.Internal.PIsDataRepr Agora.Treasury.PTreasuryRedeemer
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.Treasury.PTreasuryRedeemer s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.Treasury.PTreasuryRedeemer s)


-- | Helpers for constructing effects.
module Agora.Effect

-- | Helper "template" for creating effect validator.
--   
--   In some situations, it may be the case that we need more control over
--   how an effect is implemented. In such situations, it's okay to not use
--   this helper.
makeEffect :: forall (datum :: PType). PIsData datum => CurrencySymbol -> (forall (s :: S). Term s PCurrencySymbol -> Term s datum -> Term s PTxOutRef -> Term s (PAsData PTxInfo) -> Term s POpaque) -> ClosedTerm PValidator

-- | Dummy effect which can only burn its GAT.
noopEffect :: CurrencySymbol -> ClosedTerm PValidator
