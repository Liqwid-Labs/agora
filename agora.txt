-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package agora
@version 0.1


-- | A basic N of M multisignature validation function.
module Agora.MultiSig

-- | Check if a Haskell-level MultiSig signs this transaction.
validatedByMultisig :: MultiSig -> Term s (PTxInfo :--> PBool)

-- | Check if a Plutarch-level MultiSig signs this transaction.
pvalidatedByMultisig :: Term s (PMultiSig :--> (PTxInfo :--> PBool))

-- | Plutarch-level MultiSig
newtype PMultiSig (s :: S)
PMultiSig :: Term s (PDataRecord '["keys" := PBuiltinList (PAsData PPubKeyHash), "minSigs" := PInteger]) -> PMultiSig (s :: S)
[getMultiSig] :: PMultiSig (s :: S) -> Term s (PDataRecord '["keys" := PBuiltinList (PAsData PPubKeyHash), "minSigs" := PInteger])

-- | A MultiSig represents a proof that a particular set of signatures are
--   present on a transaction.
data MultiSig
MultiSig :: [PubKeyHash] -> Integer -> MultiSig

-- | List of PubKeyHashes that must be present in the list of signatories.
[keys] :: MultiSig -> [PubKeyHash]
[minSigs] :: MultiSig -> Integer
instance Plutarch.DataRepr.Internal.Field.PDataFields Agora.MultiSig.PMultiSig
instance Plutarch.Builtin.PIsData Agora.MultiSig.PMultiSig
instance Plutarch.Internal.PlutusType.PlutusType Agora.MultiSig.PMultiSig
instance Plutarch.DataRepr.Internal.PIsDataRepr Agora.MultiSig.PMultiSig
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.MultiSig.PMultiSig s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.MultiSig.PMultiSig s)
instance Plutarch.Lift.PConstantDecl Agora.MultiSig.MultiSig
instance Plutarch.Lift.PUnsafeLiftDecl Agora.MultiSig.PMultiSig
instance PlutusTx.IsData.Class.ToData Agora.MultiSig.MultiSig
instance PlutusTx.IsData.Class.FromData Agora.MultiSig.MultiSig
instance PlutusTx.IsData.Class.UnsafeFromData Agora.MultiSig.MultiSig
instance PlutusTx.Lift.Class.Typeable @Type PlutusCore.Default.Universe.DefaultUni Agora.MultiSig.MultiSig
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Agora.MultiSig.MultiSig
instance Generics.SOP.Universe.Generic Agora.MultiSig.MultiSig
instance GHC.Show.Show Agora.MultiSig.MultiSig
instance GHC.Classes.Eq Agora.MultiSig.MultiSig
instance GHC.Generics.Generic Agora.MultiSig.MultiSig


-- | Tags and extras for <a>Plutarch.SafeMoney</a>.
module Agora.SafeMoney

-- | ADA.
data ADATag

-- | Governance token.
data GTTag

-- | Governor ST token.
data GovernorSTTag

-- | Stake ST token.
data StakeSTTag

-- | Proposal ST token.
data ProposalSTTag

-- | Resolves ada tags.
adaRef :: Tagged ADATag AssetClass


-- | Exportable script bundles for off-chain consumption.
module Agora.ScriptInfo

-- | Bundle containing a <a>MintingPolicy</a> and its symbol.
data PolicyInfo
PolicyInfo :: MintingPolicy -> CurrencySymbol -> PolicyInfo

-- | The minting policy.
[policy] :: PolicyInfo -> MintingPolicy

-- | The symbol given by the minting policy.
[currencySymbol] :: PolicyInfo -> CurrencySymbol

-- | Bundle containing a <a>Validator</a> and its hash.
data ValidatorInfo
ValidatorInfo :: Validator -> ValidatorHash -> ValidatorInfo

-- | The validator script.
[script] :: ValidatorInfo -> Validator

-- | Hash of the validator.
[hash] :: ValidatorInfo -> ValidatorHash

-- | Create a <a>ValidatorInfo</a> given a Plutarch term.
mkValidatorInfo :: ClosedTerm PValidator -> ValidatorInfo

-- | Create a <a>PolicyInfo</a> given a Plutarch term.
mkPolicyInfo :: ClosedTerm PMintingPolicy -> PolicyInfo
instance Data.Aeson.Types.FromJSON.FromJSON Agora.ScriptInfo.ValidatorInfo
instance Data.Aeson.Types.ToJSON.ToJSON Agora.ScriptInfo.ValidatorInfo
instance GHC.Generics.Generic Agora.ScriptInfo.ValidatorInfo
instance GHC.Classes.Eq Agora.ScriptInfo.ValidatorInfo
instance GHC.Show.Show Agora.ScriptInfo.ValidatorInfo
instance Data.Aeson.Types.FromJSON.FromJSON Agora.ScriptInfo.PolicyInfo
instance Data.Aeson.Types.ToJSON.ToJSON Agora.ScriptInfo.PolicyInfo
instance GHC.Generics.Generic Agora.ScriptInfo.PolicyInfo
instance GHC.Classes.Eq Agora.ScriptInfo.PolicyInfo
instance GHC.Show.Show Agora.ScriptInfo.PolicyInfo


-- | Plutarch utility functions that should be upstreamed or don't belong
--   anywhere else.
module Agora.Utils

-- | Assert a particular <a>PBool</a>, trace if false.
tcassert :: forall r (s :: S). Term s PString -> Term s PBool -> TermCont @r s ()

-- | <a>plet</a> but for use in <a>TermCont</a>.
tclet :: forall r (s :: S) (a :: PType). Term s a -> TermCont @r s (Term s a)

-- | <a>pmatch</a> but for use in <a>TermCont</a>.
tcmatch :: forall (a :: PType) (s :: S). PlutusType a => Term s a -> TermCont s (a s)

-- | <a>ptryFrom</a> but for use in <a>TermCont</a>.
tctryFrom :: forall b a s r. PTryFrom a b => Term s a -> TermCont @r s (Term s b, Reduce (PTryFromExcess a b s))

-- | Get the first element that matches a predicate or return Nothing.
pfind' :: PIsListLike list a => (Term s a -> Term s PBool) -> Term s (list a :--> PMaybe a)

-- | Find a datum with the given hash.
pfindDatum :: Term s (PDatumHash :--> (PBuiltinList (PAsData (PTuple PDatumHash PDatum)) :--> PMaybe PDatum))

-- | Find a datum with the given hash, and <a>ptryFrom</a> it.
ptryFindDatum :: forall (a :: PType) (s :: S). PTryFrom PData a => Term s (PDatumHash :--> (PBuiltinList (PAsData (PTuple PDatumHash PDatum)) :--> PMaybe a))

-- | Sum of all value at input.
pvalueSpent :: forall (s :: S). Term s (PBuiltinList (PAsData PTxInInfo) :--> PValue 'Sorted 'Positive)

-- | Check if a PubKeyHash signs this transaction.
ptxSignedBy :: Term s (PBuiltinList (PAsData PPubKeyHash) :--> (PAsData PPubKeyHash :--> PBool))

-- | Add two <a>PValue</a>s together.
paddValue :: forall (keys :: KeyGuarantees) (as :: AmountGuarantees) (bs :: AmountGuarantees) (s :: S). Term s (PValue keys as :--> (PValue keys bs :--> PValue keys (AddGuarantees as bs)))

-- | Find the value for a given key in an associative list.
plookup :: (PEq a, PIsListLike list (PBuiltinPair a b)) => Term s (a :--> (list (PBuiltinPair a b) :--> PMaybe b))

-- | Extract a Maybe by providing a default value in case of Just.
pfromMaybe :: forall a s. Term s (a :--> (PMaybe a :--> a))

-- | Get the sum of all values belonging to a particular CurrencySymbol.
psymbolValueOf :: forall (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S). Term s (PCurrencySymbol :--> (PValue keys amounts :--> PInteger))

-- | Return <a>&gt;=</a> on two values comparing by only a particular
--   AssetClass.
pgeqByClass :: forall (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S). Term s (PCurrencySymbol :--> (PTokenName :--> (PValue keys amounts :--> (PValue keys amounts :--> PBool))))

-- | Return <a>&gt;=</a> on two values comparing by only a particular
--   CurrencySymbol.
pgeqBySymbol :: forall (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S). Term s (PCurrencySymbol :--> (PValue keys amounts :--> (PValue keys amounts :--> PBool)))

-- | Return <a>&gt;=</a> on two values comparing by only a particular
--   Haskell-level AssetClass.
pgeqByClass' :: forall (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S). AssetClass -> Term s (PValue keys amounts :--> (PValue keys amounts :--> PBool))

-- | Find the TxInInfo by a TxOutRef.
pfindTxInByTxOutRef :: Term s (PTxOutRef :--> (PBuiltinList (PAsData PTxInInfo) :--> PMaybe PTxInInfo))

-- | Create a value with a single asset class.
psingletonValue :: forall (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S). Term s (PCurrencySymbol :--> (PTokenName :--> (PInteger :--> PValue keys amounts)))

-- | Get the first element that maps to a PJust in a list.
pfindMap :: PIsListLike list a => Term s ((a :--> PMaybe b) :--> (list a :--> PMaybe b))

-- | True if a list is not empty.
pnotNull :: forall list a. PIsListLike list a => Term _ (list a :--> PBool)

-- | Yield True if a given PMaybe is of form <tt><a>PJust</a> _</tt>.
pisJust :: forall a s. Term s (PMaybe a :--> PBool)

-- | Check if a particular asset class has been spent in the input list.
--   
--   When using this as an authority check, you <b>MUST</b> ensure the
--   authority knows how to ensure its end of the contract.
ptokenSpent :: forall {s :: S}. Term s (PAssetClass :--> (PBuiltinList (PAsData PTxInInfo) :--> PBool))

-- | True if both maps have exactly the same keys. Using
--   <tt><a>#==</a></tt> is not sufficient, because keys returned are not
--   ordered.
pkeysEqual :: forall (k :: PType) (a :: PType) (b :: PType) (keys :: KeyGuarantees) (s :: S). (POrd k, PIsData k) => Term s (PMap keys k a :--> (PMap keys k b :--> PBool))

-- | <i> O(nlogn) </i>. Sort and remove dupicate elements in a list.
pnubSortBy :: forall list a (s :: S). PIsListLike list a => Term s ((a :--> (a :--> PBool)) :--> ((a :--> (a :--> PBool)) :--> (list a :--> list a)))

-- | A special case of <a>pisUniqBy</a> which requires elements have
--   <a>POrd</a> instance.
pisUniq :: forall list a (s :: S). (POrd a, PIsListLike list a) => Term s (list a :--> PBool)

-- | <i> O(nlogn) </i>. Check if a list contains no duplicates.
pisUniqBy :: forall list a (s :: S). PIsListLike list a => Term s ((a :--> (a :--> PBool)) :--> ((a :--> (a :--> PBool)) :--> (list a :--> PBool)))

-- | Yield True if a given PMaybeData is of form <tt><a>PDJust</a> _</tt>.
pisDJust :: Term s (PMaybeData a :--> PBool)

-- | Determines if a given UTXO is spent.
pisUTXOSpent :: Term s (PTxOutRef :--> (PBuiltinList (PAsData PTxInInfo) :--> PBool))

-- | <i> O(nlogn) </i>. Merge sort, bottom-up version, given a custom
--   comparator.
--   
--   Elements are arranged from lowest to highest, keeping duplicates in
--   the order they appeared in the input.
pmsortBy :: PIsListLike l a => Term s ((a :--> (a :--> PBool)) :--> (l a :--> l a))

-- | A special case of <a>pmsortBy</a> which requires elements have
--   <a>POrd</a> instance.
pmsort :: (POrd a, PIsListLike l a) => Term s (l a :--> l a)

-- | Special version of <a>pnubSortBy</a>, which requires elements have
--   <a>POrd</a>.
pnubSort :: forall list a (s :: S). (PIsListLike list a, POrd a) => Term s (list a :--> list a)

-- | <i> O(n) </i>. Update the value at a given key in a <a>PMap</a>, have
--   the same functionalities as <a>update</a>.
pupdate :: forall (k :: PType) (v :: PType) (keys :: KeyGuarantees) (s :: S). (PIsData k, PIsData v) => Term s ((v :--> PMaybe v) :--> (k :--> (PMap keys k v :--> PMap keys k v)))

-- | <i> O(n) </i>. Map a function over all values in a <a>PMap</a>.
pmapMap :: forall (k :: PType) (a :: PType) (b :: PType) (keys :: KeyGuarantees) (s :: S). (PIsData k, PIsData a, PIsData b) => Term s ((a :--> b) :--> (PMap keys k a :--> PMap keys k b))

-- | A special version of <a>pmap</a> which allows list elements to be
--   thrown out.
pmapMaybe :: forall s a list. PIsListLike list a => Term s ((a :--> PMaybe a) :--> (list a :--> list a))

-- | Finds the TxOut of an effect from TxInfo and TxOutRef
findTxOutByTxOutRef :: Term s (PTxOutRef :--> (PBuiltinList (PAsData PTxInInfo) :--> PMaybe PTxOut))

-- | Get script hash from an Address.
scriptHashFromAddress :: Term s (PAddress :--> PMaybe PValidatorHash)

-- | Find all TxOuts sent to an Address
findOutputsToAddress :: Term s (PBuiltinList (PAsData PTxOut) :--> (PAddress :--> PBuiltinList (PAsData PTxOut)))

-- | Find the data corresponding to a TxOut, if there is one
findTxOutDatum :: Term s (PBuiltinList (PAsData (PTuple PDatumHash PDatum)) :--> (PTxOut :--> PMaybe PDatum))

-- | Safely convert a <a>PValidatorHash</a> into a <a>PTokenName</a>. This
--   can be useful for tagging tokens for extra safety.
validatorHashToTokenName :: ValidatorHash -> TokenName

-- | Plutarch level <a>validatorHashToTokenName</a>.
pvalidatorHashToTokenName :: forall (s :: S). Term s PValidatorHash -> Term s PTokenName

-- | Get the CurrencySymbol of a PMintingPolicy.
getMintingPolicySymbol :: ClosedTerm PMintingPolicy -> CurrencySymbol

-- | The entire value only contains one token of the given currency symbol.
hasOnlyOneTokenOfCurrencySymbol :: forall (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S). Term s (PCurrencySymbol :--> (PValue keys amounts :--> PBool))

-- | Find datum given a maybe datum hash
mustFindDatum' :: forall (datum :: PType). (PIsData datum, PTryFrom PData (PAsData datum)) => forall s. Term s (PMaybeData PDatumHash :--> (PBuiltinList (PAsData (PTuple PDatumHash PDatum)) :--> datum))

-- | Extract the value stored in a PMaybe container. If there's no value,
--   throw an error with the given message.
mustBePJust :: forall a s. Term s (PString :--> (PMaybe a :--> a))

-- | Extract the value stored in a PMaybeData container. If there's no
--   value, throw an error with the given message.
mustBePDJust :: forall a s. PIsData a => Term s (PString :--> (PMaybeData a :--> a))

-- | Create an <a>Address</a> from a given <a>ValidatorHash</a> with no
--   <a>StakingCredential</a>.
validatorHashToAddress :: ValidatorHash -> Address

-- | <i> O(n) </i>. Merge two lists which are assumed to be ordered, given
--   a custom comparator.
pmergeBy :: PIsListLike l a => Term s ((a :--> (a :--> PBool)) :--> (l a :--> (l a :--> l a)))

-- | Split a list in half.
phalve :: PIsListLike l a => Term s (l a :--> PPair (l a) (l a))

-- | Return true if the given address is a script address.
isScriptAddress :: Term s (PAddress :--> PBool)

-- | Return true if the given credential is a pub-key-hash.
isPubKey :: Term s (PCredential :--> PBool)


-- | Time functions for proposal phases.
module Agora.Proposal.Time

-- | Configuration of proposal timings.
--   
--   See:
--   <a>https://github.com/Liqwid-Labs/agora/blob/master/docs/tech-design/proposals.md#when-may-interactions-occur</a>
data ProposalTimingConfig
ProposalTimingConfig :: POSIXTime -> POSIXTime -> POSIXTime -> POSIXTime -> ProposalTimingConfig

-- | <a>D</a>: the length of the draft period.
[draftTime] :: ProposalTimingConfig -> POSIXTime

-- | <a>V</a>: the length of the voting period.
[votingTime] :: ProposalTimingConfig -> POSIXTime

-- | <a>L</a>: the length of the locking period.
[lockingTime] :: ProposalTimingConfig -> POSIXTime

-- | <a>E</a>: the length of the execution period.
[executingTime] :: ProposalTimingConfig -> POSIXTime

-- | Represents the starting time of the proposal.
newtype ProposalStartingTime
ProposalStartingTime :: POSIXTime -> ProposalStartingTime
[getProposalStartingTime] :: ProposalStartingTime -> POSIXTime

-- | Represents the maximum width of a <a>POSIXTimeRange</a>.
newtype MaxTimeRangeWidth
MaxTimeRangeWidth :: POSIXTime -> MaxTimeRangeWidth
[getMaxWidth] :: MaxTimeRangeWidth -> POSIXTime

-- | <h2>Establishing timing in Proposal interactions.</h2>
--   
--   In Plutus, it's impossible to determine time exactly. It's also
--   impossible to get a single point in time, yet often we need to check
--   various constraints on time.
--   
--   For the purposes of proposals, there's a single most important
--   feature: The ability to determine if we can perform an action. In
--   order to correctly determine if we are able to perform certain
--   actions, we need to know what time it roughly is, compared to when the
--   proposal was created.
--   
--   <a>PProposalTime</a> represents "the time according to the proposal".
--   Its representation is opaque, and doesn't matter.
--   
--   Various functions work simply on <a>PProposalTime</a> and
--   <a>ProposalTimingConfig</a>. In particular, <a>currentProposalTime</a>
--   is useful for extracting the time from the <a>txInfoValidPeriod</a>
--   field of <a>TxInfo</a>.
--   
--   We avoid <a>PPOSIXTimeRange</a> where we can in order to save on
--   operations.
--   
--   Note: <a>PProposalTime</a> doesn't need a Haskell-level equivalent
--   because it is only used in scripts, and does not go in datums. It is
--   also scott-encoded which is more efficient in usage.
data PProposalTime (s :: S)
PProposalTime :: Term s PPOSIXTime -> Term s PPOSIXTime -> PProposalTime (s :: S)
[lowerBound] :: PProposalTime (s :: S) -> Term s PPOSIXTime
[upperBound] :: PProposalTime (s :: S) -> Term s PPOSIXTime

-- | Plutarch-level version of <a>ProposalTimingConfig</a>.
newtype PProposalTimingConfig (s :: S)
PProposalTimingConfig :: Term s (PDataRecord '["draftTime" := PPOSIXTime, "votingTime" := PPOSIXTime, "lockingTime" := PPOSIXTime, "executingTime" := PPOSIXTime]) -> PProposalTimingConfig (s :: S)
[getProposalTimingConfig] :: PProposalTimingConfig (s :: S) -> Term s (PDataRecord '["draftTime" := PPOSIXTime, "votingTime" := PPOSIXTime, "lockingTime" := PPOSIXTime, "executingTime" := PPOSIXTime])

-- | Plutarch-level version of <a>ProposalStartingTime</a>.
newtype PProposalStartingTime (s :: S)
PProposalStartingTime :: Term s PPOSIXTime -> PProposalStartingTime (s :: S)

-- | Plutarch-level version of <a>MaxTimeRangeWidth</a>.
newtype PMaxTimeRangeWidth (s :: S)
PMaxTimeRangeWidth :: Term s PPOSIXTime -> PMaxTimeRangeWidth (s :: S)

-- | Get the starting time of a proposal, from the <a>txInfoValidPeriod</a>
--   field. For every proposal, this is only meant to run once upon
--   creation. Given time range should be tight enough, meaning that the
--   width of the time range should be less than the maximum value.
createProposalStartingTime :: forall (s :: S). Term s (PMaxTimeRangeWidth :--> (PPOSIXTimeRange :--> PProposalStartingTime))

-- | Get the current proposal time, from the <a>txInfoValidPeriod</a>
--   field.
--   
--   If it's impossible to get a fully-bounded time, (e.g. either end of
--   the <a>PPOSIXTimeRange</a> is an infinity) then we error out.
currentProposalTime :: forall (s :: S). Term s (PPOSIXTimeRange :--> PProposalTime)

-- | True if the <a>PProposalTime</a> is in the draft period.
isDraftPeriod :: forall (s :: S). Term s (PProposalTimingConfig :--> (PProposalStartingTime :--> (PProposalTime :--> PBool)))

-- | True if the <a>PProposalTime</a> is in the voting period.
isVotingPeriod :: forall (s :: S). Term s (PProposalTimingConfig :--> (PProposalStartingTime :--> (PProposalTime :--> PBool)))

-- | True if the <a>PProposalTime</a> is in the locking period.
isLockingPeriod :: forall (s :: S). Term s (PProposalTimingConfig :--> (PProposalStartingTime :--> (PProposalTime :--> PBool)))

-- | True if the <a>PProposalTime</a> is in the execution period.
isExecutionPeriod :: forall (s :: S). Term s (PProposalTimingConfig :--> (PProposalStartingTime :--> (PProposalTime :--> PBool)))
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Proposal.Time.MaxTimeRangeWidth
instance PlutusTx.IsData.Class.FromData Agora.Proposal.Time.MaxTimeRangeWidth
instance PlutusTx.IsData.Class.ToData Agora.Proposal.Time.MaxTimeRangeWidth
instance GHC.Generics.Generic Agora.Proposal.Time.MaxTimeRangeWidth
instance GHC.Classes.Ord Agora.Proposal.Time.MaxTimeRangeWidth
instance GHC.Show.Show Agora.Proposal.Time.MaxTimeRangeWidth
instance GHC.Classes.Eq Agora.Proposal.Time.MaxTimeRangeWidth
instance Plutarch.Bool.PEq Agora.Proposal.Time.PProposalTime
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.HasDatatypeInfo (Agora.Proposal.Time.PProposalTime s)
instance Plutarch.Internal.PlutusType.PlutusType Agora.Proposal.Time.PProposalTime
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.Proposal.Time.PProposalTime s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.Proposal.Time.PProposalTime s)
instance Plutarch.Bool.POrd Agora.Proposal.Time.PProposalStartingTime
instance Plutarch.Bool.PEq Agora.Proposal.Time.PProposalStartingTime
instance Plutarch.Builtin.PIsData Agora.Proposal.Time.PProposalStartingTime
instance Plutarch.Internal.PlutusType.PlutusType Agora.Proposal.Time.PProposalStartingTime
instance Plutarch.DataRepr.Internal.Field.PDataFields Agora.Proposal.Time.PProposalTimingConfig
instance Plutarch.Builtin.PIsData Agora.Proposal.Time.PProposalTimingConfig
instance Plutarch.Internal.PlutusType.PlutusType Agora.Proposal.Time.PProposalTimingConfig
instance Plutarch.DataRepr.Internal.PIsDataRepr Agora.Proposal.Time.PProposalTimingConfig
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.Proposal.Time.PProposalTimingConfig s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.Proposal.Time.PProposalTimingConfig s)
instance Plutarch.Bool.POrd Agora.Proposal.Time.PMaxTimeRangeWidth
instance Plutarch.Bool.PEq Agora.Proposal.Time.PMaxTimeRangeWidth
instance Plutarch.Builtin.PIsData Agora.Proposal.Time.PMaxTimeRangeWidth
instance Plutarch.Internal.PlutusType.PlutusType Agora.Proposal.Time.PMaxTimeRangeWidth
instance Plutarch.Lift.PConstantDecl Agora.Proposal.Time.ProposalStartingTime
instance Plutarch.Lift.PConstantDecl Agora.Proposal.Time.ProposalTimingConfig
instance Plutarch.Lift.PConstantDecl Agora.Proposal.Time.MaxTimeRangeWidth
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Proposal.Time.PMaxTimeRangeWidth
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Proposal.Time.PProposalTimingConfig
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Proposal.Time.PProposalStartingTime
instance PlutusTx.IsData.Class.ToData Agora.Proposal.Time.ProposalTimingConfig
instance PlutusTx.IsData.Class.FromData Agora.Proposal.Time.ProposalTimingConfig
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Proposal.Time.ProposalTimingConfig
instance forall (s :: Plutarch.Internal.S). Plutarch.Numeric.Additive.AdditiveSemigroup (Plutarch.Internal.Term s Plutarch.Api.V1.Time.PPOSIXTime)
instance GHC.Generics.Generic Agora.Proposal.Time.ProposalStartingTime
instance GHC.Show.Show Agora.Proposal.Time.ProposalStartingTime
instance GHC.Classes.Eq Agora.Proposal.Time.ProposalStartingTime
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Proposal.Time.ProposalStartingTime
instance PlutusTx.IsData.Class.FromData Agora.Proposal.Time.ProposalStartingTime
instance PlutusTx.IsData.Class.ToData Agora.Proposal.Time.ProposalStartingTime
instance GHC.Generics.Generic Agora.Proposal.Time.ProposalTimingConfig
instance GHC.Show.Show Agora.Proposal.Time.ProposalTimingConfig
instance GHC.Classes.Eq Agora.Proposal.Time.ProposalTimingConfig


-- | Proposal scripts encoding effects that operate on the system.
module Agora.Proposal

-- | Parameters that identify the Proposal validator script.
data Proposal
Proposal :: AssetClass -> AssetClass -> Integer -> Proposal
[governorSTAssetClass] :: Proposal -> AssetClass
[stakeSTAssetClass] :: Proposal -> AssetClass

-- | Arbitrary limit for maximum amount of cosigners on a proposal.
[maximumCosigners] :: Proposal -> Integer

-- | Haskell-level datum for Proposal scripts.
data ProposalDatum
ProposalDatum :: ProposalId -> Map ResultTag (Map ValidatorHash DatumHash) -> ProposalStatus -> [PubKeyHash] -> ProposalThresholds -> ProposalVotes -> ProposalTimingConfig -> ProposalStartingTime -> ProposalDatum

-- | Identification of the proposal. TODO: could we encode this more
--   efficiently? This is shaped this way for future proofing. See
--   <a>https://github.com/Liqwid-Labs/agora/issues/39</a>
[proposalId] :: ProposalDatum -> ProposalId

-- | Effect lookup table. First by result, then by effect hash.
[effects] :: ProposalDatum -> Map ResultTag (Map ValidatorHash DatumHash)

-- | The status the proposal is in.
[status] :: ProposalDatum -> ProposalStatus

-- | Who created the proposal initially, and who cosigned it later.
[cosigners] :: ProposalDatum -> [PubKeyHash]

-- | Thresholds copied over on initialization.
[thresholds] :: ProposalDatum -> ProposalThresholds

-- | Vote tally on the proposal
[votes] :: ProposalDatum -> ProposalVotes

-- | Timing configuration copied over on initialization.
[timingConfig] :: ProposalDatum -> ProposalTimingConfig

-- | The time upon the creation of the proposal.
[startingTime] :: ProposalDatum -> ProposalStartingTime

-- | Haskell-level redeemer for Proposal scripts.
data ProposalRedeemer

-- | Cast one or more votes towards a particular <a>ResultTag</a>.
Vote :: ResultTag -> ProposalRedeemer

-- | Add one or more public keys to the cosignature list. Must be signed by
--   those cosigning.
--   
--   This is particularly used in the <a>Draft</a> <a>ProposalStatus</a>,
--   where matching <a>Stake</a>s can be called to advance the proposal,
--   provided enough GT is shared among them.
Cosign :: [PubKeyHash] -> ProposalRedeemer

-- | Allow unlocking one or more stakes with votes towards particular
--   <a>ResultTag</a>.
Unlock :: ResultTag -> ProposalRedeemer

-- | Advance the proposal, performing the required checks for whether that
--   is legal.
--   
--   These are roughly the checks for each possible transition:
--   
--   <h3><tt><a>Draft</a> -&gt; <a>VotingReady</a></tt>:</h3>
--   
--   <ol>
--   <li>The sum of all of the cosigner's GT is larger than the
--   <tt>startVoting</tt> field of <a>ProposalThresholds</a>.</li>
--   <li>The proposal's current time ensures <tt>isDraftPeriod</tt>.</li>
--   </ol>
--   
--   <h3><tt><a>VotingReady</a> -&gt; <a>Locked</a></tt>:</h3>
--   
--   <ol>
--   <li>The sum of all votes is larger than <tt>countVoting</tt>.</li>
--   <li>The winning <a>ResultTag</a> has more votes than all other
--   <a>ResultTag</a>s.</li>
--   <li>The proposal's current time ensures <tt>isVotingPeriod</tt>.</li>
--   </ol>
--   
--   <h3><tt><a>Locked</a> -&gt; <a>Finished</a></tt>:</h3>
--   
--   <ol>
--   <li>The proposal's current time ensures
--   <tt>isExecutionPeriod</tt>.</li>
--   <li>The transaction mints the GATs to the receiving effects.</li>
--   </ol>
--   
--   <h3><tt>* -&gt; <a>Finished</a></tt>:</h3>
--   
--   If the proposal has run out of time for the current
--   <a>ProposalStatus</a>, it will always be possible to transition into
--   <a>Finished</a> status, because it has expired (and failed).
AdvanceProposal :: ProposalRedeemer

-- | The "status" of the proposal. This is only useful for state
--   transitions that need to happen as a result of a transaction as
--   opposed to time-based "periods".
--   
--   See the note on wording &amp; the state machine in the tech-design.
--   
--   If the proposal is <a>VotingReady</a>, for instance, that doesn't
--   necessarily mean that voting is possible, as this also requires the
--   timing to be right.
data ProposalStatus

-- | A draft proposal represents a proposal that has yet to be realized.
--   
--   In effect, this means one which didn't have enough LQ to be a full
--   proposal, and needs cosigners to enable that to happen. This is
--   similar to a "temperature check", but only useful if multiple people
--   want to pool governance tokens together. If the proposal doesn't get
--   to <a>VotingReady</a> on time, the proposal will <b>never</b> be able
--   to get voted on.
Draft :: ProposalStatus

-- | The proposal has/had enough GT cosigned in order to be a fully fledged
--   proposal.
--   
--   This means that once the timing requirements align, proposal will be
--   able to be voted on.
VotingReady :: ProposalStatus

-- | The proposal has been voted on, and the votes have been locked
--   permanently. The proposal now goes into a locking time after the
--   normal voting time. After this, it's possible to execute the proposal.
Locked :: ProposalStatus

-- | The proposal has finished.
--   
--   This can mean it's been voted on and completed, but it can also mean
--   the proposal failed due to time constraints or didn't get to
--   <a>VotingReady</a> first.
--   
--   At this stage, the <a>votes</a> field of <a>ProposalDatum</a> is
--   frozen.
--   
--   See <a>AdvanceProposal</a> for documentation on state transitions.
--   
--   TODO: The owner of the proposal may choose to reclaim their proposal.
Finished :: ProposalStatus

-- | The threshold values for various state transitions to happen. This
--   data is stored centrally (in the <a>Governor</a>) and copied over to
--   <a>Proposal</a>s when they are created.
data ProposalThresholds
ProposalThresholds :: Tagged GTTag Integer -> Tagged GTTag Integer -> Tagged GTTag Integer -> ProposalThresholds

-- | How much GT minimum must a particular <a>ResultTag</a> accumulate for
--   it to pass.
[execute] :: ProposalThresholds -> Tagged GTTag Integer

-- | How much GT required to "create" a proposal.
--   
--   It is recommended this be a high enough amount, in order to prevent
--   DOS from bad actors.
[create] :: ProposalThresholds -> Tagged GTTag Integer

-- | How much GT required to allow voting to happen. (i.e. to move into
--   <a>VotingReady</a>)
[vote] :: ProposalThresholds -> Tagged GTTag Integer

-- | Map which encodes the total tally for each result. It's important that
--   the "shape" is consistent with the shape of <a>effects</a>.
--   
--   e.g. if the <a>effects</a> field looks like the following:
--   
--   <pre>
--   [(<a>ResultTag</a> 0, []), (<a>ResultTag</a> 1, [(vh, dh)])]
--   </pre>
--   
--   Then <a>ProposalVotes</a> needs be of the shape:
--   
--   <pre>
--   [(<a>ResultTag</a> 0, n), (<a>ResultTag</a> 1, m)]
--   </pre>
newtype ProposalVotes
ProposalVotes :: Map ResultTag Integer -> ProposalVotes
[getProposalVotes] :: ProposalVotes -> Map ResultTag Integer

-- | Identifies a Proposal, issued upon creation of a proposal. In
--   practice, this number starts at zero, and increments by one for each
--   proposal. The 100th proposal will be <tt><a>ProposalId</a> 99</tt>.
--   This counter lives in the <a>Governor</a>. See <a>nextProposalId</a>,
--   and <a>pgetNextProposalId</a>.
newtype ProposalId
ProposalId :: Integer -> ProposalId
[proposalTag] :: ProposalId -> Integer

-- | Encodes a result. Typically, for a Yes/No proposal, we encode it like
--   this:
--   
--   <pre>
--   <a>No</a>  ~ <a>ResultTag</a> 0
--   <a>Yes</a> ~ <a>ResultTag</a> 1
--   </pre>
newtype ResultTag
ResultTag :: Integer -> ResultTag
[getResultTag] :: ResultTag -> Integer

-- | Create a <a>ProposalVotes</a> that has the same shape as the
--   <a>effects</a> field.
emptyVotesFor :: forall a. Map ResultTag a -> ProposalVotes

-- | Plutarch-level version of <a>ProposalDatum</a>.
newtype PProposalDatum (s :: S)
PProposalDatum :: Term s (PDataRecord '["proposalId" := PProposalId, "effects" := PMap 'Unsorted PResultTag (PMap 'Unsorted PValidatorHash PDatumHash), "status" := PProposalStatus, "cosigners" := PBuiltinList (PAsData PPubKeyHash), "thresholds" := PProposalThresholds, "votes" := PProposalVotes, "timingConfig" := PProposalTimingConfig, "startingTime" := PProposalStartingTime]) -> PProposalDatum (s :: S)
[getProposalDatum] :: PProposalDatum (s :: S) -> Term s (PDataRecord '["proposalId" := PProposalId, "effects" := PMap 'Unsorted PResultTag (PMap 'Unsorted PValidatorHash PDatumHash), "status" := PProposalStatus, "cosigners" := PBuiltinList (PAsData PPubKeyHash), "thresholds" := PProposalThresholds, "votes" := PProposalVotes, "timingConfig" := PProposalTimingConfig, "startingTime" := PProposalStartingTime])

-- | Plutarch-level version of <a>ProposalRedeemer</a>.
data PProposalRedeemer (s :: S)
PVote :: Term s (PDataRecord '["resultTag" := PResultTag]) -> PProposalRedeemer (s :: S)
PCosign :: Term s (PDataRecord '["newCosigners" := PBuiltinList (PAsData PPubKeyHash)]) -> PProposalRedeemer (s :: S)
PUnlock :: Term s (PDataRecord '["resultTag" := PResultTag]) -> PProposalRedeemer (s :: S)
PAdvanceProposal :: Term s (PDataRecord '[]) -> PProposalRedeemer (s :: S)

-- | Plutarch-level version of <a>ProposalStatus</a>.
data PProposalStatus (s :: S)
PDraft :: Term s (PDataRecord '[]) -> PProposalStatus (s :: S)
PVotingReady :: Term s (PDataRecord '[]) -> PProposalStatus (s :: S)
PLocked :: Term s (PDataRecord '[]) -> PProposalStatus (s :: S)
PFinished :: Term s (PDataRecord '[]) -> PProposalStatus (s :: S)

-- | Plutarch-level version of <a>ProposalThresholds</a>.
newtype PProposalThresholds (s :: S)
PProposalThresholds :: Term s (PDataRecord '["execute" := PDiscrete GTTag, "create" := PDiscrete GTTag, "vote" := PDiscrete GTTag]) -> PProposalThresholds (s :: S)
[getProposalThresholds] :: PProposalThresholds (s :: S) -> Term s (PDataRecord '["execute" := PDiscrete GTTag, "create" := PDiscrete GTTag, "vote" := PDiscrete GTTag])

-- | Plutarch-level version of <a>ProposalVotes</a>.
newtype PProposalVotes (s :: S)
PProposalVotes :: Term s (PMap 'Unsorted PResultTag PInteger) -> PProposalVotes (s :: S)

-- | Plutarch-level version of <a>PProposalId</a>.
newtype PProposalId (s :: S)
PProposalId :: Term s PInteger -> PProposalId (s :: S)

-- | Plutarch-level version of <a>ResultTag</a>.
newtype PResultTag (s :: S)
PResultTag :: Term s PInteger -> PResultTag (s :: S)

-- | Check for various invariants a proposal must uphold. This can be used
--   to check both upon creation and upon any following state transitions
--   in the proposal.
proposalDatumValid :: Proposal -> Term s (PProposalDatum :--> PBool)

-- | Plutarch-level version of <a>emptyVotesFor</a>.
pemptyVotesFor :: forall s a. PIsData a => Term s (PMap 'Unsorted PResultTag a :--> PProposalVotes)

-- | Find the winner result tag, given the votes, the quorum the "neutral"
--   result tag.
--   
--   The winner should be unambiguous, meaning that if two options have the
--   same highest votes, the "neutral" option will be the winner.
pwinner :: Term s (PProposalVotes :--> (PInteger :--> (PResultTag :--> PResultTag)))

-- | Find the "neutral" option (a dummy outcome with no effect) given the
--   effects.
pneutralOption :: Term s (PMap 'Unsorted PResultTag (PMap 'Unsorted PValidatorHash PDatumHash) :--> PResultTag)
instance GHC.Generics.Generic Agora.Proposal.Proposal
instance GHC.Classes.Eq Agora.Proposal.Proposal
instance GHC.Show.Show Agora.Proposal.Proposal
instance Plutarch.Bool.POrd Agora.Proposal.PResultTag
instance Plutarch.Bool.PEq Agora.Proposal.PResultTag
instance Plutarch.Builtin.PIsData Agora.Proposal.PResultTag
instance Plutarch.Internal.PlutusType.PlutusType Agora.Proposal.PResultTag
instance Plutarch.Bool.POrd Agora.Proposal.PProposalId
instance Plutarch.Bool.PEq Agora.Proposal.PProposalId
instance Plutarch.Builtin.PIsData Agora.Proposal.PProposalId
instance Plutarch.Internal.PlutusType.PlutusType Agora.Proposal.PProposalId
instance Plutarch.Bool.PEq Agora.Proposal.PProposalStatus
instance Plutarch.Builtin.PIsData Agora.Proposal.PProposalStatus
instance Plutarch.Internal.PlutusType.PlutusType Agora.Proposal.PProposalStatus
instance Plutarch.DataRepr.Internal.PIsDataRepr Agora.Proposal.PProposalStatus
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.Proposal.PProposalStatus s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.Proposal.PProposalStatus s)
instance Plutarch.DataRepr.Internal.Field.PDataFields Agora.Proposal.PProposalThresholds
instance Plutarch.Builtin.PIsData Agora.Proposal.PProposalThresholds
instance Plutarch.Internal.PlutusType.PlutusType Agora.Proposal.PProposalThresholds
instance Plutarch.DataRepr.Internal.PIsDataRepr Agora.Proposal.PProposalThresholds
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.Proposal.PProposalThresholds s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.Proposal.PProposalThresholds s)
instance Plutarch.Builtin.PIsData Agora.Proposal.PProposalVotes
instance Plutarch.Internal.PlutusType.PlutusType Agora.Proposal.PProposalVotes
instance Plutarch.Bool.PEq Agora.Proposal.PProposalDatum
instance Plutarch.DataRepr.Internal.Field.PDataFields Agora.Proposal.PProposalDatum
instance Plutarch.Builtin.PIsData Agora.Proposal.PProposalDatum
instance Plutarch.Internal.PlutusType.PlutusType Agora.Proposal.PProposalDatum
instance Plutarch.DataRepr.Internal.PIsDataRepr Agora.Proposal.PProposalDatum
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.Proposal.PProposalDatum s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.Proposal.PProposalDatum s)
instance Plutarch.Builtin.PIsData Agora.Proposal.PProposalRedeemer
instance Plutarch.Internal.PlutusType.PlutusType Agora.Proposal.PProposalRedeemer
instance Plutarch.DataRepr.Internal.PIsDataRepr Agora.Proposal.PProposalRedeemer
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.Proposal.PProposalRedeemer s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.Proposal.PProposalRedeemer s)
instance Plutarch.Lift.PConstantDecl Agora.Proposal.ResultTag
instance Plutarch.Lift.PConstantDecl Agora.Proposal.ProposalId
instance Plutarch.Lift.PConstantDecl Agora.Proposal.ProposalStatus
instance Plutarch.Lift.PConstantDecl Agora.Proposal.ProposalThresholds
instance Plutarch.Lift.PConstantDecl Agora.Proposal.ProposalVotes
instance Plutarch.Lift.PConstantDecl Agora.Proposal.ProposalDatum
instance Plutarch.Lift.PConstantDecl Agora.Proposal.ProposalRedeemer
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Agora.Proposal.PProposalRedeemer)
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Proposal.PProposalRedeemer
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Agora.Proposal.PProposalDatum)
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Proposal.PProposalDatum
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Proposal.PProposalVotes
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Proposal.PProposalThresholds
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Proposal.PProposalStatus
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Agora.Proposal.PProposalId)
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Proposal.PProposalId
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Proposal.PResultTag
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Agora.Proposal.PResultTag)
instance PlutusTx.IsData.Class.ToData Agora.Proposal.ProposalRedeemer
instance PlutusTx.IsData.Class.FromData Agora.Proposal.ProposalRedeemer
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Proposal.ProposalRedeemer
instance GHC.Generics.Generic Agora.Proposal.ProposalRedeemer
instance GHC.Show.Show Agora.Proposal.ProposalRedeemer
instance GHC.Classes.Eq Agora.Proposal.ProposalRedeemer
instance PlutusTx.IsData.Class.ToData Agora.Proposal.ProposalDatum
instance PlutusTx.IsData.Class.FromData Agora.Proposal.ProposalDatum
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Proposal.ProposalDatum
instance GHC.Generics.Generic Agora.Proposal.ProposalVotes
instance GHC.Show.Show Agora.Proposal.ProposalVotes
instance GHC.Classes.Eq Agora.Proposal.ProposalVotes
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Proposal.ProposalVotes
instance PlutusTx.IsData.Class.FromData Agora.Proposal.ProposalVotes
instance PlutusTx.IsData.Class.ToData Agora.Proposal.ProposalVotes
instance GHC.Generics.Generic Agora.Proposal.ProposalDatum
instance GHC.Show.Show Agora.Proposal.ProposalDatum
instance GHC.Classes.Eq Agora.Proposal.ProposalDatum
instance PlutusTx.IsData.Class.ToData Agora.Proposal.ProposalThresholds
instance PlutusTx.IsData.Class.FromData Agora.Proposal.ProposalThresholds
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Proposal.ProposalThresholds
instance GHC.Generics.Generic Agora.Proposal.ProposalThresholds
instance GHC.Show.Show Agora.Proposal.ProposalThresholds
instance GHC.Classes.Eq Agora.Proposal.ProposalThresholds
instance PlutusTx.IsData.Class.ToData Agora.Proposal.ProposalStatus
instance PlutusTx.IsData.Class.FromData Agora.Proposal.ProposalStatus
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Proposal.ProposalStatus
instance GHC.Generics.Generic Agora.Proposal.ProposalId
instance GHC.Show.Show Agora.Proposal.ProposalId
instance GHC.Classes.Eq Agora.Proposal.ProposalId
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Proposal.ProposalId
instance PlutusTx.IsData.Class.FromData Agora.Proposal.ProposalId
instance PlutusTx.IsData.Class.ToData Agora.Proposal.ProposalId
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Proposal.ResultTag
instance PlutusTx.IsData.Class.FromData Agora.Proposal.ResultTag
instance PlutusTx.IsData.Class.ToData Agora.Proposal.ResultTag
instance GHC.Generics.Generic Agora.Proposal.ResultTag
instance GHC.Classes.Ord Agora.Proposal.ResultTag
instance GHC.Show.Show Agora.Proposal.ResultTag
instance GHC.Classes.Eq Agora.Proposal.ResultTag
instance GHC.Generics.Generic Agora.Proposal.ProposalStatus
instance GHC.Show.Show Agora.Proposal.ProposalStatus
instance GHC.Classes.Eq Agora.Proposal.ProposalStatus


-- | Vote-lockable stake UTXOs holding GT.
module Agora.Stake

-- | Haskell-level datum for Stake scripts.
data StakeDatum
StakeDatum :: Tagged GTTag Integer -> PubKeyHash -> [ProposalLock] -> StakeDatum

-- | Tracks the amount of governance token staked in the datum. This also
--   acts as the voting weight for <a>Proposal</a>s.
[stakedAmount] :: StakeDatum -> Tagged GTTag Integer

-- | The hash of the public key this stake belongs to.
--   
--   TODO Support for MultiSig/Scripts is tracked here:
--   <a>https://github.com/Liqwid-Labs/agora/issues/45</a>
[owner] :: StakeDatum -> PubKeyHash

-- | The current proposals locking this stake. This field must be empty for
--   the stake to be usable for deposits and withdrawals.
[lockedBy] :: StakeDatum -> [ProposalLock]

-- | Haskell-level redeemer for Stake scripts.
data StakeRedeemer

-- | Deposit or withdraw a discrete amount of the staked governance token.
--   Stake must be unlocked.
DepositWithdraw :: Tagged GTTag Integer -> StakeRedeemer

-- | Destroy a stake, retrieving its LQ, the minimum ADA and any other
--   assets. Stake must be unlocked.
Destroy :: StakeRedeemer

-- | Permit a Vote to be added onto a <a>Proposal</a>. This also adds a
--   lock to the <a>lockedBy</a> field. See <a>ProposalLock</a>. This needs
--   to be done in sync with casting a vote, otherwise it's possible for a
--   lock to be permanently placed on the stake, and then the funds are
--   lost.
PermitVote :: ProposalLock -> StakeRedeemer

-- | Retract a vote, removing it from the <a>lockedBy</a> field. See
--   <a>ProposalLock</a>. This action checks for permission of the
--   <a>Proposal</a>. Finished proposals are always allowed to have votes
--   retracted and won't affect the Proposal datum, allowing <a>Stake</a>s
--   to be unlocked.
RetractVotes :: [ProposalLock] -> StakeRedeemer

-- | The owner can consume stake if nothing is changed about it. If the
--   proposal token moves, this is equivalent to the owner consuming it.
WitnessStake :: StakeRedeemer

-- | Parameters for creating Stake scripts.
data Stake
Stake :: Tagged GTTag AssetClass -> AssetClass -> Stake

-- | Used when inlining the AssetClass of a <a>PDiscrete</a> in the script
--   code.
[gtClassRef] :: Stake -> Tagged GTTag AssetClass
[proposalSTClass] :: Stake -> AssetClass

-- | A lock placed on a Stake datum in order to prevent depositing and
--   withdrawing when votes are in place.
--   
--   NOTE: Due to retracting votes always being possible, this lock will
--   only lock with contention on the proposal.
--   
--   FIXME: Contention on Proposals could create contention on voting which
--   in turn creates contention on stakers.
--   
--   Vaguely this is the dependency graph for this locking interaction.
--   Both the stake validator and the proposal validator are only able to
--   check for one another through the datum belonging to the ST:
--   
--   <pre>
--   ┌─────────────────┐   ┌────────────────────┐
--   │ Stake Validator ├─┐ │ Proposal Validator │
--   └────────┬────────┘ │ └──────┬─────┬───────┘
--            │          │        │     │
--            │        ┌─┼────────┘     │
--            ▼        │ │              ▼
--   ┌──────────────┐  │ │ ┌─────────────────┐
--   │ Stake Policy │◄─┘ └►│ Proposal Policy │
--   └──────────────┘      └─────────────────┘
--   
--   </pre>
data ProposalLock
ProposalLock :: ResultTag -> ProposalId -> ProposalLock

-- | What was voted on. This allows retracting votes to undo their vote.
[vote] :: ProposalLock -> ResultTag

-- | Identifies the proposal. See <a>ProposalId</a> for further comments on
--   its significance.
[proposalId] :: ProposalLock -> ProposalId

-- | Plutarch-level datum for Stake scripts.
newtype PStakeDatum (s :: S)
PStakeDatum :: Term s (PDataRecord '["stakedAmount" := PDiscrete GTTag, "owner" := PPubKeyHash, "lockedBy" := PBuiltinList (PAsData PProposalLock)]) -> PStakeDatum (s :: S)
[getStakeDatum] :: PStakeDatum (s :: S) -> Term s (PDataRecord '["stakedAmount" := PDiscrete GTTag, "owner" := PPubKeyHash, "lockedBy" := PBuiltinList (PAsData PProposalLock)])

-- | Plutarch-level redeemer for Stake scripts.
data PStakeRedeemer (s :: S)

-- | Deposit or withdraw a discrete amount of the staked governance token.
PDepositWithdraw :: Term s (PDataRecord '["delta" := PDiscrete GTTag]) -> PStakeRedeemer (s :: S)

-- | Destroy a stake, retrieving its LQ, the minimum ADA and any other
--   assets.
PDestroy :: Term s (PDataRecord '[]) -> PStakeRedeemer (s :: S)
PPermitVote :: Term s (PDataRecord '["lock" := PProposalLock]) -> PStakeRedeemer (s :: S)
PRetractVotes :: Term s (PDataRecord '["locks" := PBuiltinList (PAsData PProposalLock)]) -> PStakeRedeemer (s :: S)
PWitnessStake :: Term s (PDataRecord '[]) -> PStakeRedeemer (s :: S)

-- | Plutarch-level version of <a>ProposalLock</a>.
newtype PProposalLock (s :: S)
PProposalLock :: Term s (PDataRecord '["vote" := PResultTag, "proposalTag" := PProposalId]) -> PProposalLock (s :: S)
[getProposalLock] :: PProposalLock (s :: S) -> Term s (PDataRecord '["vote" := PResultTag, "proposalTag" := PProposalId])

-- | Check whether a Stake is locked. If it is locked, various actions are
--   unavailable.
stakeLocked :: forall (s :: S). Term s (PStakeDatum :--> PBool)

-- | Find a stake owned by a particular PK.
findStakeOwnedBy :: Term s (PAssetClass :--> (PPubKeyHash :--> (PBuiltinList (PAsData (PTuple PDatumHash PDatum)) :--> (PBuiltinList (PAsData PTxInInfo) :--> PMaybe (PAsData PStakeDatum)))))
instance Plutarch.Bool.PEq Agora.Stake.PProposalLock
instance Plutarch.DataRepr.Internal.Field.PDataFields Agora.Stake.PProposalLock
instance Plutarch.Builtin.PIsData Agora.Stake.PProposalLock
instance Plutarch.Internal.PlutusType.PlutusType Agora.Stake.PProposalLock
instance Plutarch.DataRepr.Internal.PIsDataRepr Agora.Stake.PProposalLock
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.Stake.PProposalLock s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.Stake.PProposalLock s)
instance Plutarch.Builtin.PIsData Agora.Stake.PStakeRedeemer
instance Plutarch.Internal.PlutusType.PlutusType Agora.Stake.PStakeRedeemer
instance Plutarch.DataRepr.Internal.PIsDataRepr Agora.Stake.PStakeRedeemer
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.Stake.PStakeRedeemer s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.Stake.PStakeRedeemer s)
instance Plutarch.Bool.PEq Agora.Stake.PStakeDatum
instance Plutarch.DataRepr.Internal.Field.PDataFields Agora.Stake.PStakeDatum
instance Plutarch.Builtin.PIsData Agora.Stake.PStakeDatum
instance Plutarch.Internal.PlutusType.PlutusType Agora.Stake.PStakeDatum
instance Plutarch.DataRepr.Internal.PIsDataRepr Agora.Stake.PStakeDatum
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.Stake.PStakeDatum s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.Stake.PStakeDatum s)
instance Plutarch.Lift.PConstantDecl Agora.Stake.StakeDatum
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Agora.Stake.PStakeRedeemer)
instance Plutarch.Lift.PConstantDecl Agora.Stake.StakeRedeemer
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Agora.Stake.PProposalLock)
instance Plutarch.Lift.PConstantDecl Agora.Stake.ProposalLock
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Agora.Stake.PStakeDatum)
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Stake.PStakeDatum
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Stake.PStakeRedeemer
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Stake.PProposalLock
instance PlutusTx.IsData.Class.ToData Agora.Stake.StakeDatum
instance PlutusTx.IsData.Class.FromData Agora.Stake.StakeDatum
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Stake.StakeDatum
instance GHC.Generics.Generic Agora.Stake.StakeDatum
instance GHC.Show.Show Agora.Stake.StakeDatum
instance PlutusTx.IsData.Class.ToData Agora.Stake.StakeRedeemer
instance PlutusTx.IsData.Class.FromData Agora.Stake.StakeRedeemer
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Stake.StakeRedeemer
instance GHC.Generics.Generic Agora.Stake.StakeRedeemer
instance GHC.Show.Show Agora.Stake.StakeRedeemer
instance PlutusTx.IsData.Class.ToData Agora.Stake.ProposalLock
instance PlutusTx.IsData.Class.FromData Agora.Stake.ProposalLock
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Stake.ProposalLock
instance GHC.Generics.Generic Agora.Stake.Stake
instance GHC.Generics.Generic Agora.Stake.ProposalLock
instance GHC.Show.Show Agora.Stake.ProposalLock


-- | Plutus Scripts for Stakes.
module Agora.Stake.Scripts

-- | Policy for Stake state threads.
--   
--   <h2>What this Policy does</h2>
--   
--   <h3>For minting:</h3>
--   
--   <ul>
--   <li>Check that exactly one state thread is minted.</li>
--   <li>Check that an output exists with a state thread and a valid
--   datum.</li>
--   <li>Check that no state thread is an input.</li>
--   <li>assert <tt><a>TokenName</a> == <a>ValidatorHash</a></tt> of the
--   script that we pay to.</li>
--   </ul>
--   
--   <h3>For burning:</h3>
--   
--   <ul>
--   <li>Check that exactly one state thread is burned.</li>
--   <li>Check that datum at state thread is valid and not locked.</li>
--   </ul>
stakePolicy :: Tagged GTTag AssetClass -> ClosedTerm PMintingPolicy

-- | Validator intended for Stake UTXOs to be locked by.
--   
--   <h2>What this Validator does:</h2>
--   
--   <h3><a>DepositWithdraw</a></h3>
--   
--   Deposit or withdraw some GT to the stake.
--   
--   <ul>
--   <li>Tx must be signed by the owner.</li>
--   <li>The <a>stakedAmount</a> field must be updated.</li>
--   <li>The stake must not be locked.</li>
--   <li>The new UTXO must have the previous value plus the difference as
--   stated by the redeemer.</li>
--   </ul>
--   
--   <h3><a>PermitVote</a></h3>
--   
--   Allow a <a>ProposalLock</a> to be put on the stake in order to vote on
--   a proposal.
--   
--   <ul>
--   <li>A proposal token must be spent alongside the stake.</li>
--   <li>Its total votes must be correctly updated to include this stake's
--   contribution.</li>
--   <li>Tx must be signed by the owner.</li>
--   </ul>
--   
--   <h3><a>RetractVotes</a></h3>
--   
--   Remove a <a>ProposalLock</a> set when voting on a proposal.
--   
--   <ul>
--   <li>A proposal token must be spent alongside the stake.</li>
--   <li>Tx must be signed by the owner.</li>
--   </ul>
--   
--   <h3><a>Destroy</a></h3>
--   
--   Destroy the stake in order to reclaim the min ADA.
--   
--   <ul>
--   <li>The stake must not be locked.</li>
--   <li>Tx must be signed by the owner.</li>
--   </ul>
--   
--   <h3><a>WitnessStake</a></h3>
--   
--   Allow this Stake to be included in a transaction without making any
--   changes to it. In the future, this could use <a>CIP-31</a> instead.
--   
--   <ul>
--   <li>Tx must be signed by the owner <b>or</b> a proposal ST token must
--   be spent alongside the stake.</li>
--   <li>The datum and value must remain unchanged.</li>
--   </ul>
stakeValidator :: Stake -> ClosedTerm PValidator


-- | Plutus Scripts for Proposals.
module Agora.Proposal.Scripts

-- | The validator for Proposals.
--   
--   The documentation for various of the redeemers lives at
--   <a>ProposalRedeemer</a>.
--   
--   <h2>What this validator does</h2>
--   
--   <h3>Voting/unlocking</h3>
--   
--   When voting and unlocking, the proposal must witness a state
--   transition occuring in the relevant Stake. This transition must place
--   a lock on the stake that is tagged with the right <a>ResultTag</a>,
--   and <a>ProposalId</a>.
--   
--   <h3>Periods</h3>
--   
--   Most redeemers are time-sensitive.
--   
--   A list of all time-sensitive redeemers and their requirements:
--   
--   <ul>
--   <li><a>Vote</a> can only be used when both the status is in
--   <a>VotingReady</a>, and <a>isVotingPeriod</a> is true.</li>
--   <li><a>Cosign</a> can only be used when both the status is in
--   <a>Draft</a>, and <a>isDraftPeriod</a> is true.</li>
--   <li><a>AdvanceProposal</a> can only be used when the status can be
--   advanced (see <a>AdvanceProposal</a> docs).</li>
--   <li><a>Unlock</a> is always valid.</li>
--   </ul>
proposalValidator :: Proposal -> ClosedTerm PValidator

-- | Policy for Proposals.
--   
--   <h2>What this policy does</h2>
--   
--   <h3>For minting:</h3>
--   
--   <ul>
--   <li>Governor is happy with mint.</li>
--   </ul>
--   
--   <ul>
--   <li>The governor must do most of the checking for the validity of the
--   transaction. For example, the governor must check that the datum is
--   correct, and that the ST is correctly paid to the right
--   validator.</li>
--   <li>Exactly 1 token is minted.</li>
--   </ul>
--   
--   <h3>For burning:</h3>
--   
--   <ul>
--   <li>This policy cannot be burned.</li>
--   </ul>
proposalPolicy :: AssetClass -> ClosedTerm PMintingPolicy


-- | Governor entity scripts acting as authority of entire system.
module Agora.Governor

-- | Datum for the Governor script.
data GovernorDatum
GovernorDatum :: ProposalThresholds -> ProposalId -> ProposalTimingConfig -> MaxTimeRangeWidth -> GovernorDatum

-- | Gets copied over upon creation of a <a>ProposalDatum</a>.
[proposalThresholds] :: GovernorDatum -> ProposalThresholds

-- | What tag the next proposal will get upon creating.
[nextProposalId] :: GovernorDatum -> ProposalId

-- | The timing configuration for proposals. Will get copied over upon the
--   creation of proposals.
[proposalTimings] :: GovernorDatum -> ProposalTimingConfig

-- | The maximum valid duration of a transaction that creats a proposal.
[createProposalTimeRangeMaxWidth] :: GovernorDatum -> MaxTimeRangeWidth

-- | Redeemer for Governor script. The governor has two primary
--   responsibilities:
--   
--   <ol>
--   <li>The gating of Proposal creation.</li>
--   <li>The gating of minting authority tokens.</li>
--   </ol>
--   
--   Parameters of the governor can also be mutated by an effect.
data GovernorRedeemer

-- | Checks that a proposal was created lawfully, and allows it.
CreateProposal :: GovernorRedeemer

-- | Checks that a SINGLE proposal finished correctly, and allows minting
--   GATs for each effect script.
MintGATs :: GovernorRedeemer

-- | Allows effects to mutate the parameters.
MutateGovernor :: GovernorRedeemer

-- | Parameters for creating Governor scripts.
data Governor
Governor :: TxOutRef -> Tagged GTTag AssetClass -> Integer -> Governor

-- | Referenced utxo will be spent to mint the GST.
[gstOutRef] :: Governor -> TxOutRef

-- | Governance token of the system.
[gtClassRef] :: Governor -> Tagged GTTag AssetClass

-- | Arbitrary limit for maximum amount of cosigners on a proposal. See
--   <a>proposalDatumValid</a>.
[maximumCosigners] :: Governor -> Integer

-- | Plutarch-level datum for the Governor script.
newtype PGovernorDatum (s :: S)
PGovernorDatum :: Term s (PDataRecord '["proposalThresholds" := PProposalThresholds, "nextProposalId" := PProposalId, "proposalTimings" := PProposalTimingConfig, "createProposalTimeRangeMaxWidth" := PMaxTimeRangeWidth]) -> PGovernorDatum (s :: S)
[getGovernorDatum] :: PGovernorDatum (s :: S) -> Term s (PDataRecord '["proposalThresholds" := PProposalThresholds, "nextProposalId" := PProposalId, "proposalTimings" := PProposalTimingConfig, "createProposalTimeRangeMaxWidth" := PMaxTimeRangeWidth])

-- | Plutarch-level version of <a>GovernorRedeemer</a>.
data PGovernorRedeemer (s :: S)
PCreateProposal :: Term s (PDataRecord '[]) -> PGovernorRedeemer (s :: S)
PMintGATs :: Term s (PDataRecord '[]) -> PGovernorRedeemer (s :: S)
PMutateGovernor :: Term s (PDataRecord '[]) -> PGovernorRedeemer (s :: S)

-- | Plutrach version of <a>getNextProposalId</a>.
pgetNextProposalId :: Term s (PProposalId :--> PProposalId)

-- | Get next proposal id.
getNextProposalId :: ProposalId -> ProposalId

-- | Check whether a particular <a>PGovernorDatum</a> is well-formed.
governorDatumValid :: Term s (PGovernorDatum :--> PBool)
instance GHC.Generics.Generic Agora.Governor.Governor
instance Plutarch.Bool.PEq Agora.Governor.PGovernorDatum
instance Plutarch.DataRepr.Internal.Field.PDataFields Agora.Governor.PGovernorDatum
instance Plutarch.Builtin.PIsData Agora.Governor.PGovernorDatum
instance Plutarch.Internal.PlutusType.PlutusType Agora.Governor.PGovernorDatum
instance Plutarch.DataRepr.Internal.PIsDataRepr Agora.Governor.PGovernorDatum
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.Governor.PGovernorDatum s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.Governor.PGovernorDatum s)
instance Plutarch.Builtin.PIsData Agora.Governor.PGovernorRedeemer
instance Plutarch.Internal.PlutusType.PlutusType Agora.Governor.PGovernorRedeemer
instance Plutarch.DataRepr.Internal.PIsDataRepr Agora.Governor.PGovernorRedeemer
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.Governor.PGovernorRedeemer s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.Governor.PGovernorRedeemer s)
instance Plutarch.Lift.PConstantDecl Agora.Governor.GovernorDatum
instance Plutarch.Lift.PConstantDecl Agora.Governor.GovernorRedeemer
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Agora.Governor.PGovernorRedeemer)
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Governor.PGovernorRedeemer
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Governor.PGovernorDatum
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Agora.Governor.PGovernorDatum)
instance PlutusTx.IsData.Class.ToData Agora.Governor.GovernorRedeemer
instance PlutusTx.IsData.Class.FromData Agora.Governor.GovernorRedeemer
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Governor.GovernorRedeemer
instance GHC.Generics.Generic Agora.Governor.GovernorRedeemer
instance GHC.Show.Show Agora.Governor.GovernorRedeemer
instance PlutusTx.IsData.Class.ToData Agora.Governor.GovernorDatum
instance PlutusTx.IsData.Class.FromData Agora.Governor.GovernorDatum
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Governor.GovernorDatum
instance GHC.Generics.Generic Agora.Governor.GovernorDatum
instance GHC.Show.Show Agora.Governor.GovernorDatum


-- | Tokens acting as redeemable proofs of DAO authority.
module Agora.AuthorityToken

-- | Policy given <a>AuthorityToken</a> params.
authorityTokenPolicy :: AuthorityToken -> ClosedTerm PMintingPolicy

-- | Check that all GATs are valid in a particular TxOut. How this is
--   checked: an AuthorityToken should never leave the Effect it was
--   initially sent to, so we simply check that the script address the
--   token resides in matches the TokenName. Since the TokenName was tagged
--   upon mint with the Effect script it was sent to, this is enough to
--   prove validity. In other words, check that all assets of a particular
--   currency symbol are tagged with a TokenName that matches where they
--   live.
authorityTokensValidIn :: Term s (PCurrencySymbol :--> (PTxOut :--> PBool))

-- | Assert that a single authority token has been burned.
singleAuthorityTokenBurned :: forall (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S). Term s PCurrencySymbol -> Term s (PAsData PTxInfo) -> Term s (PValue keys amounts) -> Term s PBool

-- | An AuthorityToken represents a proof that a particular token moved
--   while this token was minted. In effect, this means that the validator
--   that locked such a token must have approved said transaction. Said
--   validator should be made aware of *this* token's existence in order to
--   prevent incorrect minting.
newtype AuthorityToken
AuthorityToken :: AssetClass -> AuthorityToken

-- | Token that must move in order for minting this to be valid.
[authority] :: AuthorityToken -> AssetClass
instance GHC.Generics.Generic Agora.AuthorityToken.AuthorityToken


-- | Contains the datum, redeemer and validator for a template DAO
--   treasury.
module Agora.Treasury

-- | Redeemer for Treasury actions.
data TreasuryRedeemer

-- | Allow transaction to pass by delegating to GAT burn.
SpendTreasuryGAT :: TreasuryRedeemer

-- | Plutarch level type representing valid redeemers of the treasury.
newtype PTreasuryRedeemer (s :: S)

-- | Alters treasury parameters, subject to the burning of a governance
--   authority token.
PSpendTreasuryGAT :: Term s (PDataRecord '[]) -> PTreasuryRedeemer (s :: S)

-- | Validator ensuring that transactions consuming the treasury do so in a
--   valid manner.
treasuryValidator :: CurrencySymbol -> ClosedTerm PValidator
instance Plutarch.Builtin.PIsData Agora.Treasury.PTreasuryRedeemer
instance Plutarch.Internal.PlutusType.PlutusType Agora.Treasury.PTreasuryRedeemer
instance Plutarch.DataRepr.Internal.PIsDataRepr Agora.Treasury.PTreasuryRedeemer
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.Treasury.PTreasuryRedeemer s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.Treasury.PTreasuryRedeemer s)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Agora.Treasury.PTreasuryRedeemer)
instance Plutarch.Lift.PConstantDecl Agora.Treasury.TreasuryRedeemer
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Treasury.PTreasuryRedeemer
instance PlutusTx.IsData.Class.ToData Agora.Treasury.TreasuryRedeemer
instance PlutusTx.IsData.Class.FromData Agora.Treasury.TreasuryRedeemer
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Treasury.TreasuryRedeemer
instance GHC.Generics.Generic Agora.Treasury.TreasuryRedeemer
instance GHC.Show.Show Agora.Treasury.TreasuryRedeemer
instance GHC.Classes.Eq Agora.Treasury.TreasuryRedeemer


-- | Plutus scripts for Governors.
module Agora.Governor.Scripts

-- | Policy for minting GSTs.
--   
--   This policy perform the following checks:
--   
--   <ul>
--   <li>The UTXO referenced in the parameter is spent in the
--   transaction.</li>
--   <li>Exactly one GST is minted.</li>
--   <li>Ensure the token name is empty.</li>
--   <li>Said UTXO should carry a valid <a>GovernorDatum</a>.</li>
--   </ul>
--   
--   NOTE: It's user's responsibility to make sure the token is sent to the
--   corresponding governor validator. We <i>can't</i> really check this in
--   the policy, otherwise we create a cyclic reference issue.
governorPolicy :: Governor -> ClosedTerm PMintingPolicy

-- | Validator for Governors.
--   
--   <h2>Common checks</h2>
--   
--   The validator always ensures:
--   
--   <ul>
--   <li>The UTXO which holds the GST must be spent.</li>
--   <li>The GST always stays at the validator's address.</li>
--   <li>The new state UTXO has a valid datum of type
--   <a>GovernorDatum</a>.</li>
--   </ul>
--   
--   <h2>Creating a Proposal</h2>
--   
--   When the redeemer is <a>CreateProposal</a>, the script will check:
--   
--   <ul>
--   <li>For governor's state datum:<ul><li><a>nextProposalId</a> is
--   advanced.</li><li>Nothing is changed other that that.</li></ul></li>
--   <li>Exactly one stake (the "input stake") must be provided in the
--   input:</li>
--   <li>At least <a>stackedAmount</a> of GT must be spent in the
--   transaction.</li>
--   <li>The transaction must be signed by the stake owner.</li>
--   <li>Exactly one new proposal state token is minted.</li>
--   <li>An UTXO which holds the newly minted proposal state token is sent
--   to the proposal validator. This UTXO must have a valid datum of type
--   <a>ProposalDatum</a>, the datum must:<ul><li>Copy its id and
--   thresholds from the governor's state.</li><li>Have status set to
--   <a>Draft</a>.</li><li>Have zero votes.</li><li>Have exactly one
--   cosigner - the stake owner</li></ul></li>
--   <li>An UTXO which holds the stake state token is sent back to the
--   stake validator. This UTXO must have a valid datum of type
--   <a>StakeDatum</a>:<ul><li>The <a>stakedAmount</a> and <a>owner</a>
--   should not be changed, comparing to the input stake.</li><li>The new
--   proposal locks must be appended to the <a>lockedBy</a>.</li></ul></li>
--   </ul>
--   
--   <h2>Minting GATs</h2>
--   
--   When the redeemer is <a>MintGATs</a>, the script will check:
--   
--   <ul>
--   <li>Governor's state is not changed.</li>
--   <li>Exactly only one proposal is in the inputs. Let's call this the
--   <i>input proposal</i>.</li>
--   <li>The proposal is in the <a>Executable</a> state.</li>
--   </ul>
--   
--   NOTE: The input proposal is found by looking for the UTXO with a
--   proposal state token in the inputs.
--   
--   <h3>Effect Group Selection</h3>
--   
--   Currently a proposal can have two or more than two options to vote on,
--   meaning that it can contains two or more effect groups, according to
--   <a>#39</a>.
--   
--   Either way, the shapes of <a>votes</a> and <a>effects</a> should be
--   the same. This is checked by <a>proposalDatumValid</a>.
--   
--   The script will look at the the <a>votes</a> to determine which group
--   has the highest votes, said group shoud be executed.
--   
--   During the process, minimum votes requirement will also be enforced.
--   
--   Next, the script will:
--   
--   <ul>
--   <li>Ensure that for every effect in the said effect group, exactly one
--   valid GAT is minted and sent to the effect.</li>
--   <li>The amount of GAT minted in the transaction should be equal to the
--   number of effects.</li>
--   <li>A new UTXO is sent to the proposal validator, this UTXO
--   should:<ul><li>Include the one proposal state token.</li><li>Have a
--   valid datum of type <a>ProposalDatum</a>. This datum should be as same
--   as the one of the input proposal, except its status should be
--   <a>Finished</a>.</li></ul></li>
--   </ul>
--   
--   <h2>Changing the State</h2>
--   
--   Redeemer <a>MutateGovernor</a> allows the state datum to be changed by
--   an external effect.
--   
--   In this case, the script will check
--   
--   <ul>
--   <li>Exactly one GAT is burnt in the transaction.</li>
--   <li>Said GAT is tagged by the effect.</li>
--   </ul>
governorValidator :: Governor -> ClosedTerm PValidator

-- | Get the <a>CurrencySymbol</a> of GST.
governorSTSymbolFromGovernor :: Governor -> CurrencySymbol

-- | Get the <a>AssetClass</a> of GST.
governorSTAssetClassFromGovernor :: Governor -> AssetClass

-- | Get the <a>AssetClass</a> of the proposal state token.
proposalSTAssetClassFromGovernor :: Governor -> AssetClass

-- | Get the <a>CurrencySymbol</a> of the stake token/
stakeSTSymbolFromGovernor :: Governor -> CurrencySymbol

-- | Get the <a>Stake</a> parameter, given the <a>Governor</a> parameter.
stakeFromGovernor :: Governor -> Stake

-- | Get the hash of <a>stakePolicy</a>.
stakeValidatorHashFromGovernor :: Governor -> ValidatorHash

-- | Get the <a>Proposal</a> parameter, given the <a>Governor</a>
--   parameter.
proposalFromGovernor :: Governor -> Proposal

-- | Get the hash of <a>proposalPolicy</a>.
proposalValidatorHashFromGovernor :: Governor -> ValidatorHash

-- | Get the <a>CurrencySymbol</a> of the proposal state token.
proposalSTSymbolFromGovernor :: Governor -> CurrencySymbol

-- | Get the <a>AssetClass</a> of the stake token.
--   
--   Note that the token is tagged with the hash of the stake validator.
--   See <a>stakePolicy</a>.
stakeSTAssetClassFromGovernor :: Governor -> AssetClass

-- | Get the hash of <a>proposalValidator</a>.
governorValidatorHash :: Governor -> ValidatorHash

-- | Get the <a>AuthorityToken</a> parameter given the <a>Governor</a>
--   parameter.
authorityTokenFromGovernor :: Governor -> AuthorityToken

-- | Get the <a>CurrencySymbol</a> of the authority token.
authorityTokenSymbolFromGovernor :: Governor -> CurrencySymbol


-- | Helpers for constructing effects.
module Agora.Effect

-- | Helper "template" for creating effect validator.
--   
--   In some situations, it may be the case that we need more control over
--   how an effect is implemented. In such situations, it's okay to not use
--   this helper.
makeEffect :: forall (datum :: PType). (PIsData datum, PTryFrom PData (PAsData datum)) => CurrencySymbol -> (forall (s :: S). Term s PCurrencySymbol -> Term s datum -> Term s PTxOutRef -> Term s (PAsData PTxInfo) -> Term s POpaque) -> ClosedTerm PValidator


-- | An Effect that withdraws treasury deposit
module Agora.Effect.TreasuryWithdrawal

-- | Datum that encodes behavior of Treasury Withdrawal effect.
--   
--   Note: This Datum acts like a "predefined redeemer". Which is to say
--   that it encodes the properties a redeemer would, but is locked
--   in-place until spend.
data TreasuryWithdrawalDatum
TreasuryWithdrawalDatum :: [(Credential, Value)] -> [Credential] -> TreasuryWithdrawalDatum

-- | AssocMap for Value sent to each receiver from the treasury.
[receivers] :: TreasuryWithdrawalDatum -> [(Credential, Value)]

-- | What Credentials is spending from legal.
[treasuries] :: TreasuryWithdrawalDatum -> [Credential]

-- | Haskell-level version of <a>TreasuryWithdrawalDatum</a>.
newtype PTreasuryWithdrawalDatum (s :: S)
PTreasuryWithdrawalDatum :: Term s (PDataRecord '["receivers" := PBuiltinList (PAsData (PTuple PCredential (PValue 'Sorted 'Positive))), "treasuries" := PBuiltinList (PAsData PCredential)]) -> PTreasuryWithdrawalDatum (s :: S)

-- | Withdraws given list of values to specific target addresses. It can be
--   evoked by burning GAT. The transaction should have correct outputs to
--   the users and any left overs should be paid back to the treasury.
--   
--   The validator does not accept any Redeemer as all "parameters" are
--   provided via encoded Datum.
--   
--   Note: It should check... 1. Transaction outputs should contain all of
--   what Datum specified 2. Left over assets should be redirected back to
--   Treasury It can be more flexiable over... - The number of outputs
--   themselves
treasuryWithdrawalValidator :: forall {s :: S}. CurrencySymbol -> Term s PValidator
instance Plutarch.DataRepr.Internal.Field.PDataFields Agora.Effect.TreasuryWithdrawal.PTreasuryWithdrawalDatum
instance Plutarch.Builtin.PIsData Agora.Effect.TreasuryWithdrawal.PTreasuryWithdrawalDatum
instance Plutarch.Internal.PlutusType.PlutusType Agora.Effect.TreasuryWithdrawal.PTreasuryWithdrawalDatum
instance Plutarch.DataRepr.Internal.PIsDataRepr Agora.Effect.TreasuryWithdrawal.PTreasuryWithdrawalDatum
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.Effect.TreasuryWithdrawal.PTreasuryWithdrawalDatum s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.Effect.TreasuryWithdrawal.PTreasuryWithdrawalDatum s)
instance Plutarch.Lift.PConstantDecl Agora.Effect.TreasuryWithdrawal.TreasuryWithdrawalDatum
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Effect.TreasuryWithdrawal.PTreasuryWithdrawalDatum
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Agora.Effect.TreasuryWithdrawal.PTreasuryWithdrawalDatum)
instance PlutusTx.IsData.Class.ToData Agora.Effect.TreasuryWithdrawal.TreasuryWithdrawalDatum
instance PlutusTx.IsData.Class.FromData Agora.Effect.TreasuryWithdrawal.TreasuryWithdrawalDatum
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Effect.TreasuryWithdrawal.TreasuryWithdrawalDatum
instance PlutusTx.Lift.Class.Typeable @Type PlutusCore.Default.Universe.DefaultUni Agora.Effect.TreasuryWithdrawal.TreasuryWithdrawalDatum
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Agora.Effect.TreasuryWithdrawal.TreasuryWithdrawalDatum
instance Generics.SOP.Universe.Generic Agora.Effect.TreasuryWithdrawal.TreasuryWithdrawalDatum
instance GHC.Generics.Generic Agora.Effect.TreasuryWithdrawal.TreasuryWithdrawalDatum
instance GHC.Show.Show Agora.Effect.TreasuryWithdrawal.TreasuryWithdrawalDatum


-- | A dumb effect that only burns its GAT.
module Agora.Effect.NoOp

-- | Dummy effect which can only burn its GAT.
noOpValidator :: CurrencySymbol -> ClosedTerm PValidator

-- | Dummy datum for NoOp effect.
data PNoOp (s :: S)
instance Plutarch.Builtin.PIsData Agora.Effect.NoOp.PNoOp
instance Plutarch.Internal.PlutusType.PlutusType Agora.Effect.NoOp.PNoOp
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Agora.Effect.NoOp.PNoOp)


-- | An effect for mutating governor settings.
module Agora.Effect.GovernorMutation

-- | Haskell-level datum for the governor mutation effect script.
data MutateGovernorDatum
MutateGovernorDatum :: TxOutRef -> GovernorDatum -> MutateGovernorDatum

-- | Referenced governor state UTXO should be updated by the effect.
[governorRef] :: MutateGovernorDatum -> TxOutRef

-- | The new settings for the governor.
[newDatum] :: MutateGovernorDatum -> GovernorDatum

-- | Plutarch-level version of <a>MutateGovernorDatum</a>.
newtype PMutateGovernorDatum (s :: S)
PMutateGovernorDatum :: Term s (PDataRecord '["governorRef" := PTxOutRef, "newDatum" := PGovernorDatum]) -> PMutateGovernorDatum (s :: S)

-- | Validator for the governor mutation effect.
--   
--   This effect is implemented using the <a>makeEffect</a> wrapper,
--   meaning that the burning of GAT is checked in said wrapper.
--   
--   In order to locate the governor, the validator is parametrized with a
--   <a>Governor</a>.
--   
--   All the information it needs to validate the effect is encoded in the
--   <a>MutateGovernorDatum</a>, so regardless what redeemer it's given, it
--   will check:
--   
--   <ul>
--   <li>No token is minted/burnt other than GAT.</li>
--   <li>Nothing is being paid to the the effect validator.</li>
--   <li>The governor's state UTXO must be spent:<ul><li>It carries exactly
--   one GST.</li><li>It's referenced by <a>governorRef</a> in the effect's
--   datum.</li></ul></li>
--   <li>A new state UTXO is paid to the governor:<ul><li>It contains the
--   GST.</li><li>It has valid governor state datum.</li><li>The datum is
--   exactly the same as the <a>newDatum</a>.</li></ul></li>
--   </ul>
mutateGovernorValidator :: Governor -> ClosedTerm PValidator
instance Plutarch.Bool.PEq Agora.Effect.GovernorMutation.PMutateGovernorDatum
instance Plutarch.DataRepr.Internal.Field.PDataFields Agora.Effect.GovernorMutation.PMutateGovernorDatum
instance Plutarch.Builtin.PIsData Agora.Effect.GovernorMutation.PMutateGovernorDatum
instance Plutarch.Internal.PlutusType.PlutusType Agora.Effect.GovernorMutation.PMutateGovernorDatum
instance Plutarch.DataRepr.Internal.PIsDataRepr Agora.Effect.GovernorMutation.PMutateGovernorDatum
instance forall (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Agora.Effect.GovernorMutation.PMutateGovernorDatum s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Agora.Effect.GovernorMutation.PMutateGovernorDatum s)
instance Plutarch.Lift.PConstantDecl Agora.Effect.GovernorMutation.MutateGovernorDatum
instance Plutarch.Lift.PUnsafeLiftDecl Agora.Effect.GovernorMutation.PMutateGovernorDatum
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Agora.Effect.GovernorMutation.PMutateGovernorDatum)
instance PlutusTx.IsData.Class.ToData Agora.Effect.GovernorMutation.MutateGovernorDatum
instance PlutusTx.IsData.Class.FromData Agora.Effect.GovernorMutation.MutateGovernorDatum
instance PlutusTx.IsData.Class.UnsafeFromData Agora.Effect.GovernorMutation.MutateGovernorDatum
instance Generics.SOP.Universe.Generic Agora.Effect.GovernorMutation.MutateGovernorDatum
instance GHC.Generics.Generic Agora.Effect.GovernorMutation.MutateGovernorDatum
instance GHC.Show.Show Agora.Effect.GovernorMutation.MutateGovernorDatum
